{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Minos","text":"<p>Minos is a Python project for [insert short description].</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Feature 1</li> <li>Feature 2</li> <li>Feature 3</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>```bash pip install -e .</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof","title":"<code>ParafoilSimulation_6Dof</code>","text":"<p>A class to simulate the dynamics of a parafoil system in 6 degrees of freedom.</p> <p>The simulation includes the effects of aerodynamic forces, moments, and gravity. doesnt include the effects of the payload, apparent mass</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>class ParafoilSimulation_6Dof:\n    \"\"\"\n    A class to simulate the dynamics of a parafoil system in 6 degrees of freedom.\n\n    The simulation includes the effects of aerodynamic forces, moments, and gravity.\n    doesnt include the effects of the payload, apparent mass\n    \"\"\"\n\n    def __init__(self,params,state, inputs):\n        \"\"\"\n        Initialize the simulation.\n\n        Parameters\n        ----------\n        params : dict\n            System parameters such as mass, geometry, and aerodynamic coefficients.\n\n        state : list\n            Initial state vector [position, velocity_body, eulers, angular_velocity].\n\n        inputs : list\n            Simulation inputs [flap deflection angles, wind vector].\n        \"\"\"\n        self.set_system_params(params)\n        self.set_inputs(inputs)\n        self.set_state(state)\n        self.error = False\n        # calculate the derivatives\n        self.calculate_derivatives()\n\n    def set_inputs(self,inputs):\n        \"\"\"\n        Set the inputs for the simulation.\n\n        Parameters\n        ----------\n        inputs : list\n            A list containing:\n            - input[0]: Tuple[float, float], flap deflection angles (left, right).\n            - input[1]: np.ndarray, wind vector in the inertial frame.\n        \"\"\"\n        self.set_actual_flaps(inputs[0])\n        self.w = inputs[1] # wind vector in inertial frame\n\n    def set_actual_flaps(self, input):\n        \"\"\"\n        Set both actual and desired flap deflections.\n\n        Parameters\n        ----------\n        input : tuple of float\n            Left and right flap deflections (radians).\n        \"\"\"\n\n        self.flap_l,self.flap_r = input\n        self.flap_l_desired,self.flap_r_desired = input\n        self.update_flaps(1) # doesnt matter, they be the same\n\n    def set_desired_flaps(self, input):\n        \"\"\"\n        Set desired flap deflections.\n\n        Parameters\n        ----------\n        input : tuple of float\n            Desired left and right flap deflections (radians).\n        \"\"\"\n\n        self.flap_l_desired,self.flap_r_desired = input\n\n    def update_flaps(self,dt):\n        \"\"\"\n        Update flap positions based on the desired values and rate limits.\n\n        Parameters\n        ----------\n        dt : float\n            Time step (seconds).\n        \"\"\"\n        max_rate = dt/self.flap_time_constant\n        self.flap_l += np.clip(self.flap_l_desired - self.flap_l, -max_rate, max_rate) \n        self.flap_r += np.clip(self.flap_r_desired - self.flap_r, -max_rate, max_rate) \n        # calculate the flap deflection angles\n        self.delta_a = self.flap_r - self.flap_l  # asymmetric flap deflection\n        self.delta_s = 0.5*(self.flap_l + self.flap_r) # symmetric flap deflection\n\n    def set_state(self, state):\n        self.p = state[0] # position in inertial frame\n        self.vb = self.safe_clamp_vector(state[1]) # velocity in body fixed frame\n        self.eulers = state[2] # euler angles IN RADIANS of body in inertal frame\n        self.angular_vel = self.safe_clamp_vector(state[3]) # angular velocities in body fixed frame\n        # update the transformations:\n        self.update_kinematic_transforations()\n        self.update_wind_transformations()\n\n    def set_coefficients(self, coefficients=None):\n        \"\"\"\n        Set the aerodynamic coefficients for the simulation.\n        Accepts either a list (in predefined order) or a dictionary (by name).\n        \"\"\"\n        if coefficients is None:\n            return\n\n        # Handle dictionary input\n        if isinstance(coefficients, dict):\n            for name in [\n                \"CDo\", \"CDa\", \"CD_sym\", \"CLo\", \"CLa\", \"CL_sym\",\n                \"CYB\", \"ClB\", \"Clp\", \"Clr\", \"Cl_asym\", \"Cmo\",\n                \"Cma\", \"Cmq\", \"CnB\", \"Cn_p\", \"Cn_r\", \"Cn_asym\"\n            ]:\n                if name in coefficients:\n                    setattr(self, name, coefficients[name])\n            return\n\n        # Handle list input\n        if isinstance(coefficients, list) or isinstance(coefficients, tuple):\n            if len(coefficients) &lt; 18:\n                raise ValueError(\"Coefficient list must have at least 18 values.\")\n            (\n                self.CDo, self.CDa, self.CD_sym,\n                self.CLo, self.CLa, self.CL_sym,\n                self.CYB, self.ClB, self.Clp, self.Clr, self.Cl_asym,\n                self.Cmo, self.Cma, self.Cmq,\n                self.CnB, self.Cn_p, self.Cn_r, self.Cn_asym\n            ) = coefficients\n            return\n\n    def check_set_param(self, dict, param_name):\n        \"\"\"\n        Check if the parameter is set in the dictionary and if its type matches the expected type.\n        If so, sets the instance variable self.&lt;attr_name&gt; to the value from the dictionary.\n        \"\"\"\n        param = dict.get(param_name)\n        if param is None:\n            return False\n        elif not hasattr(self, param_name):\n            raise AttributeError(f\"Attribute '{param_name}' does not exist on the instance.\")\n        elif type(getattr(self, param_name)) != type(param):\n            raise TypeError(f\"Parameter '{param_name}' should be of type {type(getattr(self, param_name))}. Got {type(param)} instead.\")\n\n        setattr(self, param_name, param)\n\n        # print(f\"Set {param_name} to {param}\")\n        return True\n\n    def set_system_params(self,system_params):\n        \"\"\"\n        Set the system parameters for the simulation. Default values follow Snowflake PAD model.\n\n        see: Yakimenko, Oleg A.. (2015). &lt;i&gt;Precision Aerial Delivery Systems - Modeling, Dynamics, and Control\n\n                Parameters\n        ----------\n        params : dict\n            Keys must include:\n            - m : float, mass [kg]\n            - b : float, span [m]\n            - S : float, area [m^2]\n            - c : float, chord [m]\n            - x_cg : float, CG x-location [m]\n            - z_cg : float, CG z-location [m]\n            - Ixx, Iyy, Izz, Ixz : float, inertia terms\n            - flap_time_constant : float, flap actuator time constant\n            - C_* : float, aerodynamic coefficients\n        \"\"\"\n        # ------------------- simulation params --------------\n        self.dt = 0.1\n        self.check_set_param(system_params, \"dt\")\n\n        # -------------------- parafoil params\n\n        # aerodynamic parameters, default values follow Snowflake PAD model.\n        self.S = 1.0\n        self.check_set_param(system_params, \"S\") # surface area of parafoil\n        self.c = 0.75\n        self.check_set_param(system_params, \"c\") # mean chord length\n        #self.AR = 0.0\n        #self.check_set_param(system_params, self.AR, \"AR\") # aspect ratio\n        self.t = 0.075\n        self.check_set_param(system_params, \"t\") # thickness of the parafoil\n        self.b = 1.35\n        self.check_set_param(system_params, \"b\") # wingspan of the parafoil\n        self.rigging_angle = np.radians(-12.0)\n        self.check_set_param(system_params, \"rigging_angle\")\n\n        # system parameters\n        self.m = 2.4 # mass of the system\n        self.check_set_param(system_params, \"m\") # mass of the system\n        self.Rp = np.array([0.0,0,-1.11]) # distance between parafoil and the center of mass for the system\n\n\n        self.check_set_param(system_params, \"Rp\")\n\n        self.I = np.array([[0.42,0,0.03],[0,0.4,0],[0.03,0,0.053]]) # moment of inertia of the system\n        # if we have to do our own calculations, we need more info\n        self.check_set_param(system_params, \"I\") # moment of inertia of the system\n\n\n        self.initial_pos = [0,0,0] # initial position of the system in inertial frame\n        self.check_set_param(system_params, \"initial_pos\")\n\n        self.flap_time_constant = 1 # number of seconds to go from 0 flap to max flap\n        self.check_set_param(system_params, \"flap_time_constant\")\n\n        \"\"\"\"\n        self.parafoil_mass = 0.0\n        self.check_set_param(system_params,self.parafoil_mass, \"parafoil_mass\") # mass of parafoil\n        self.payload_mass = 0.0\n        self.check_set_param(system_params,self.payload_mass, \"payload_mass\") # mass of payload\n        self.Rlc = 0.0\n        self.check_set_param(system_params,self.Rlc, \"Rlc\") # distance between payload CoM and connection point to parafoil\n        self.Rpc = 0.0\n        self.check_set_param(system_params,self.Rpc, \"Rpc\") # distance between parafoil CoM and connection point to parafoil\n\n        self.m = self.parafoil_mass + self.payload_mass # mass of entire system\n\n        \"\"\"\n\n        # ________________ aerodynamic parameters ____________________\n        # for drag\n        self.CD = 0\n        self.CDo = 0.25\n        self.check_set_param(system_params, \"CDo\")\n        self.CDa = 0.12\n        self.check_set_param(system_params, \"CDa\") # drag coefficient\n        self.CD_sym = 0.2\n        self.check_set_param(system_params, \"CD_sym\")\n\n        # for lift\n        self.CL = 0\n        self.CLo = 0.091\n        self.check_set_param(system_params, \"CL\") # lift coefficient\n        self.CLa = 0.90\n        self.check_set_param(system_params, \"CLa\") # lift coefficient changing due to angle of incidance\n        self.CL_sym = 0.2\n        self.check_set_param(system_params, \"CL_sym\") # lift coefficient changing due to angle of incidance\n\n        # for side force\n        self.CYB = -0.23\n        self.check_set_param(system_params, \"CYB\") # side force coefficient\n\n        # for rolling\n        self.Cl = 0\n        self.ClB = -0.036 # coefficient due to sideslip angle\n        self.check_set_param(system_params, \"clB\")\n        self.Clp = -0.84\n        self.check_set_param(system_params,\"Clp\")\n        self.Clr = -0.082\n        self.check_set_param(system_params,\"Clr\")\n        self.Cl_asym = -0.0035 # coefficient due to asymmetric flap deflection\n        self.check_set_param(system_params, \"Cl_asym\")\n\n        # for pitching\n        self.Cm = 0\n        self.Cmo = 0.35 # coefficient at zero lift\n        self.check_set_param(system_params, \"Cmo\")\n        self.Cma = -0.72 # coefficient due to angle of incidance\n        self.check_set_param(system_params, \"Cma\")\n        self.Cmq = -1.49\n        self.check_set_param(system_params, \"Cmq\") # coefficient due to pitch rate\n\n        # for yawing\n        self.Cn = 0\n        self.CnB = -0.0015 # coefficient due to sideslip angle\n        self.check_set_param(system_params, \"CnB\")\n        self.Cn_p = -0.082 # coefficient due to roll rate\n        self.check_set_param(system_params, \"Cn_p\")\n        self.Cn_r = -0.27\n        self.check_set_param(system_params, \"Cn_r\") # coefficient due to yaw rate\n        self.Cn_asym = 0.0115\n        self.check_set_param(system_params, \"Cn_asym\") # coefficient due to asymmetric flap deflection           \n\n    def get_state(self):\n        \"\"\"\n        Get the current state vector.\n\n        Returns\n        -------\n        list\n            [position, velocity_body, eulers, angular_velocity].\n        \"\"\"\n        return [self.p, self.vb, self.eulers, self.angular_vel]\n\n    def get_inertial_position(self):\n        ned_to_world = np.array([1, 1, -1])  # Flip Z-axis\n        inertial_pos = self.initial_pos + ned_to_world * self.p  # Element-wise multiplication\n        return inertial_pos\n\n    def get_inertial_state(self):\n        return[self.get_inertial_position(), self.body_to_inertial(self.vb), self.eulers, self.get_euler_rates()]\n\n    def get_CDM(self, euler_angles = None):\n        \"\"\"\n        Get the rotation matrix from body to inertial frame\"\"\"\n        if euler_angles is None:\n            phi, theta, psi = self.eulers\n        else:\n            phi, theta, psi = euler_angles\n        return np.array([\n        [np.cos(theta) * np.cos(psi), np.sin(phi) * np.sin(theta) * np.cos(psi) - np.cos(phi) * np.sin(psi), np.cos(phi) * np.sin(theta) * np.cos(psi) + np.sin(phi) * np.sin(psi)],\n        [np.cos(theta) * np.sin(psi), np.sin(phi) * np.sin(theta) * np.sin(psi) + np.cos(phi) * np.cos(psi), np.cos(phi) * np.sin(theta) * np.sin(psi) - np.sin(phi) * np.cos(psi)],\n        [-np.sin(theta), np.sin(phi) * np.cos(theta), np.cos(phi) * np.cos(theta)]\n        ])\n\n    def get_euler_rates(self, angular_vel = None):\n        \"\"\"\n        Get the euler rates from the angular velocity vector.\n        \"\"\"\n        if angular_vel is None:\n            angular_vel = self.angular_vel\n        return np.dot(self.T_angularVel_to_EulerRates, angular_vel)\n\n    def get_angular_vel_skew(self, angular_vel = None):\n        \"\"\"\n        Get the skew symmetric matrix of the angular velocity vector.\n        \"\"\"\n        if angular_vel is None:\n            p, q, r = self.angular_vel\n        else:\n            p, q, r = angular_vel\n        return np.array([\n            [0, -r, q],\n            [r, 0, -p],\n            [-q, p, 0]\n        ])\n\n    def get_angular_vel_to_EulerRates_matrix(self, euler_angles = None):\n        \"\"\"\n        Get the transformation matrix from angular velocity to euler rates.\n        \"\"\"\n        if euler_angles is None:\n            phi, theta, psi = self.eulers\n        else:\n            phi, theta, psi = euler_angles\n        if abs(theta - np.pi/2) &lt; 0.1:\n            self.error = True\n            # print(\"theta is close to 90.\")\n            theta = np.pi/2 * 0.999\n        return np.array([\n            [1, np.sin(phi) * np.tan(theta), np.cos(phi) * np.tan(theta)],\n            [0, np.cos(phi), -np.sin(phi)],\n            [0, np.sin(phi) / np.cos(theta), np.cos(phi) / np.cos(theta)]\n        ])\n\n    def update_kinematic_transforations(self, euler_angles = None, angular_vel = None):\n        \"\"\"\n        Update the kinematic transformations based on the current state.\n        \"\"\"\n        if euler_angles is None:\n            euler_angles = self.eulers\n        if angular_vel is None:\n            angular_vel = self.angular_vel\n        self.CDM = self.get_CDM(euler_angles)\n        self.angular_vel_skew = self.get_angular_vel_skew(angular_vel)\n        self.T_angularVel_to_EulerRates = self.get_angular_vel_to_EulerRates_matrix(euler_angles)\n\n    def update_wind_transformations(self):\n        epsilon = 1e-8  # small value to prevent division by zero\n        # calculate local airspeed in body fixed frame\n        self.va = self.vb - self.body_to_inertial(self.w, True) # local airspeed in body fixed frame\n        if np.all(np.isfinite(self.va)):\n            self.va_mag = np.linalg.norm(self.va) # magnitude of the local airspeed in body fixed frame\n        else:\n            self.error = True\n            #print(f\"Warning: Invalid airspeed vector: va={self.va}, vb = {self.vb}\")\n            self.va = np.array([epsilon,epsilon,epsilon])\n            self.va_mag = epsilon \n\n\n\n        # Angle of attack: arctangent of vertical to forward airspeed\n        self.angle_of_attack = np.arctan2(self.va[2], self.va[0] if abs(self.va[0]) &gt; epsilon else epsilon * np.sign(self.va[0]))\n\n        # Sideslip angle: arctangent of lateral to horizontal (forward + vertical) airspeed\n        denom = np.sqrt(self.va[0]**2 + self.va[2]**2)\n        denom_safe = denom if denom &gt; epsilon else epsilon\n        self.sideslip_angle = np.arctan2(self.va[1], denom_safe)\n\n        # calculate the rotation matrix wind to body\n        self.R_wb = np.array([\n            [np.cos(self.angle_of_attack) * np.cos(self.sideslip_angle), -np.sin(self.sideslip_angle), np.cos(self.sideslip_angle) * np.sin(self.angle_of_attack)],\n            [np.sin(self.angle_of_attack) * np.cos(self.sideslip_angle), np.cos(self.angle_of_attack), np.sin(self.angle_of_attack) * np.sin(self.sideslip_angle)],\n            [-np.sin(self.angle_of_attack), 0, np.cos(self.angle_of_attack)]\n        ])\n\n    def body_to_inertial(self,vector, inverse = False):\n        R_bi = self.CDM.T if inverse else self.CDM\n        return np.dot(R_bi, vector)\n\n    def body_to_wind(self,vector, inverse = False):\n        R_bw = self.R_wb if inverse else self.R_wb.T\n        return np.dot(R_bw, vector)\n\n    def calculate_aero_force_coeff(self):\n        # for lifting\n        self.CL = self.CLo + self.CLa * (self.angle_of_attack + self.rigging_angle) + self.CL_sym*self.delta_s\n\n        # for drag\n        self.CD = self.CDo + self.CDa * (self.angle_of_attack + self.rigging_angle)\n\n        # for side force\n        self.CY = - self.CYB * self.sideslip_angle\n\n        return [self.CD, self.CY, self.CL]\n\n    def calculate_aero_moment_coeff(self):\n\n        # for rolling\n        self.Cl = self.ClB * self.sideslip_angle + self.Cl_asym * self.delta_a + \\\n                    self.Clp * self.c/(2*self.va_mag) * self.angular_vel[0]+ \\\n                    self.Clr * self.c/(2*self.va_mag) * self.angular_vel[2] \n\n        # for pitching\n        self.Cm = self.Cmo + self.Cma * (self.angle_of_attack + self.rigging_angle) + \\\n                    self.Cmq * self.c/(2*self.va_mag) * self.angular_vel[1]\n\n        # for yawing\n        self.Cn = self.CnB * self.sideslip_angle + self.Cn_asym * self.delta_a + \\\n                    self.Cn_p * self.c/(2*self.va_mag) * self.angular_vel[0] + \\\n                    self.Cn_r * self.c/(2*self.va_mag) * self.angular_vel[2]\n\n        return [self.Cl, self.Cm, self.Cn]\n\n    def calculate_aero_forces(self):\n        self.calculate_aero_force_coeff()\n        # calculate the components\n        Fa_x = 0.5 * p_density * self.va_mag**2 * self.S * self.CD\n        Fa_y = 0.5 * p_density * self.va_mag**2 * self.S * self.CY\n        Fa_z = 0.5 * p_density * self.va_mag**2 * self.S * self.CL\n\n        F_aero_A = np.array([Fa_x,Fa_y,Fa_z])\n        F_aero_A = self.safe_clamp_vector(F_aero_A)\n        # rotate forces to the body frame and negify\n        self.F_aero = - self.body_to_wind(F_aero_A, False)\n        return self.F_aero\n\n    def calculate_aero_moments(self):\n        self.calculate_aero_moment_coeff()\n\n        L = 0.5 * p_density * self.va_mag**2 * self.S * self.b * self.Cl\n        M = 0.5 * p_density * self.va_mag**2 * self.S * self.c * self.Cm\n        N = 0.5 * p_density * self.va_mag**2 * self.S * self.b * self.Cn\n        # since \n        M_aero_A = np.array([L,M,N])\n        M_aero_A = self.safe_clamp_vector(M_aero_A)\n        # rotate moments to the body frame\n        # self.M_aero = self.body_to_wind(M_aero_A,True)\n        self.M_aero = M_aero_A\n        return self.M_aero\n\n    def calculate_derivatives(self):        \n        # calculate the aero forces\n        F_aero = self.calculate_aero_forces()\n\n        # calculate the gravity force\n        # theta, phi = self.eulers[1], self.eulers[2]\n        self.F_g = self.body_to_inertial([0,0,self.m*9.81],True)\n\n        # calculate acceleration\n        self.F_fictious = 0 - self.m * np.dot(self.angular_vel_skew, self.vb)\n        F_total = F_aero + self.F_g + self.F_fictious\n        self.acc = F_total / self.m\n\n\n        # calculate the aerodynamic moments\n        self.calculate_aero_moments()\n        #print(\"     M_aero: \", M_aero)\n        # calculate the moments due to aerodynamic forces\n        self.M_f_aero = np.cross(self.Rp,F_aero)\n        #print(\"     M_f_aero: \", M_f_aero)\n        # calculate the anglular acceleration\n        self.M_fictious = - np.dot(self.angular_vel_skew, np.dot(self.I, self.angular_vel))\n        self.M_total = self.M_aero + self.M_fictious\n        I_inv = np.linalg.inv(self.I)\n        self.angular_acc = np.dot(I_inv,self.M_total)\n        return [self.acc,self.angular_acc]\n\n    def calculate_apparent_mass_matrices(self):\n            # Correlation factors for flat parafoil\n\n        AR = self.b/self.c\n        R = np.sqrt((self.b/2)**2 + np.linalg.norm(self.Rp)**2) # line length\n        k_A  = 0.848\n        k_B  = 0.34  # use avg or upper bound of 1.24 if needed\n        k_C  = AR / (1 + AR)\n\n        # 3D corrected factors\n        k_A_star  = 0.84 * AR / (1 + AR)\n        k_B_star  = 1.161 * AR / (1 + AR)\n        k_C_star  = 0.848\n\n        # Apparent mass (flat parafoil)\n        m_x_flat = self.rho * k_A  * (np.pi / 4) * self.t**2 * self.b\n        m_y_flat = self.rho * k_B  * (np.pi / 4) * self.t**2 * self.c\n        m_z_flat = self.rho * k_C  * (np.pi / 4) * self.c**2 * self.b\n\n        # Apparent moments of inertia (flat parafoil)\n        I_x_flat = self.rho * k_A  * (np.pi / 48) * self.c**2 * self.b**3\n        I_y_flat = self.rho * k_B  * (np.pi / 48) * self.c**4 * self.b\n        I_z_flat = self.rho * k_C  * (np.pi / 48) * self.t**2 * self.b**3\n\n                # Geometry\n        a_bar = (R - R * np.cos(e0)) / (2 * R * np.sin(e0))  # Mean curvature\n        a1 = self.c / 2\n        a2 = self.b / 2\n\n        # Apparent Masses\n        m_x = m_x_flat * (1 + (8/3) * a_bar**2)\n        m_y = (1 / a1**2) * (R**2 * m_y_flat + I_x_flat)\n        m_z = m_z_flat * np.sqrt(1 + 2 * a_bar**2 * (1 - self.t**2))\n\n        # Apparent Moments of Inertia\n        I_x = (a1**2 / a1**2) * R**2 * m_y_flat + (a2**2 / a1**2) * I_x_flat\n        I_y = I_y_flat * (1 + (np.pi / 6) * (1 + AR) * AR * a_bar**2 * self.t**2)\n        I_z = (1 + 8 * a_bar**2) * I_z_flat\n\n        I_am = np.dot(np.identity(3),[m_x,m_y,m_z])\n        I_ai = np.dot(np.identity(3),[I_x,I_y,I_z])\n\n    def calculate_moments_of_inertia(self):\n        \"\"\"\n        Computes the moments of inertia of system in the body frame.\n\n        Parameters\n        ----------\n            R: 3x3 numpy array\n                Rotation matrix from parafoil frame to body frame.\n\n        Returns\n        -------\n            I_rotated: 3x3 numpy array\n                Inertia tensor in the rotated frame.\n        \"\"\"\n        # Principle moments of inertia of the parafoil\n        Ix_parafoil = 1.0\n        Iy_parafoil = 2.0\n        Iz_parafoil = 3.0\n        # Rotation matrix from parafoil frame to body frame\n        R = np.array([\n            [np.cos(self.rigging_angle), 0, np.sin(self.rigging_angle)],\n            [0, 1, 0],\n            [-np.sin(self.rigging_angle), 0, np.cos(self.rigging_angle)]\n        ])\n\n        # Principle inertia tensor\n        I_parafoil = np.diag([Ix_parafoil, Iy_parafoil, Iz_parafoil])\n\n        # Rotate into the new frame\n        I_rotated_parafoil = R @ I_parafoil @ R.T\n\n        # ___________ payload moment of inertia _____________\n\n        # define the inertia tensor of the payload, atm assume to be cylindrical\n        Ix_payload = 0.1\n        Iy_payload = 0.1\n        Iz_payload = 0.1\n\n        # principle inertia tensor of the payload\n        I_payload = np.diag([Ix_payload, Iy_payload, Iz_payload])\n\n        # ___________ Inertias at coM  _____________\n        # calculate the inertia tensor at the center of mass\n        # CoM of the system assumed to be at coM of Payload\n        # use parallel axis theorem to represent parafoil tensor at coM of system\n\n        # distance between parafoil and payload\n        d = np.array([0, 0, self.Rp])\n        d_outer = np.outer(d, d)\n        I_parafoil_at_com = I_rotated_parafoil + self.parafoil_mass * ((np.dot(d, d) * np.eye(3)) - d_outer)\n\n        # calculate the inertia tensor at the center of mass\n        self.I = I_parafoil_at_com + I_payload\n\n    def get_solver_derivatives(self,state):\n        old_state = self.get_state()\n        self.set_state(state)\n        # Calculate the derivatives\n        self.calculate_derivatives() \n        # get eular rates\n        euler_rates = np.dot(self.T_angularVel_to_EulerRates, self.angular_vel)\n        # deritives for the vars: [position, velocity, euler angles, angular velocity]\n        derivatives = [self.body_to_inertial(self.vb),self.acc,euler_rates,self.angular_acc]\n        # Reset the simulation state to the original\n        self.set_state(old_state)\n        return derivatives\n\n    def safe_clamp_vector(self, vec, max_abs=1e3):\n        \"\"\"\n        Clamp a 3D vector to avoid NaN, inf, and excessively large values.\n\n        Parameters\n        ----------\n            vec (np.ndarray): Input 3D vector.\n            max_abs (float): Maximum allowed absolute value for each component.\n\n        Returns\n        -------\n            np.ndarray: A safe, clamped 3D vector.\n        \"\"\"\n        safe_vec = np.zeros(3)\n\n        for i in range(3):\n            val = vec[i]\n            if not np.isfinite(val):\n                #print(\"clamping\")\n                self.error = True\n                safe_vec[i] = 0.0\n            elif abs(val) &gt; max_abs:\n                #print()\n                self.error = True\n                safe_vec[i] = np.clip(val, -max_abs, max_abs)\n            else:\n                safe_vec[i] = val\n\n        return safe_vec\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.__init__","title":"<code>__init__(params, state, inputs)</code>","text":"<p>Initialize the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>System parameters such as mass, geometry, and aerodynamic coefficients.</p> required <code>state</code> <code>list</code> <p>Initial state vector [position, velocity_body, eulers, angular_velocity].</p> required <code>inputs</code> <code>list</code> <p>Simulation inputs [flap deflection angles, wind vector].</p> required Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def __init__(self,params,state, inputs):\n    \"\"\"\n    Initialize the simulation.\n\n    Parameters\n    ----------\n    params : dict\n        System parameters such as mass, geometry, and aerodynamic coefficients.\n\n    state : list\n        Initial state vector [position, velocity_body, eulers, angular_velocity].\n\n    inputs : list\n        Simulation inputs [flap deflection angles, wind vector].\n    \"\"\"\n    self.set_system_params(params)\n    self.set_inputs(inputs)\n    self.set_state(state)\n    self.error = False\n    # calculate the derivatives\n    self.calculate_derivatives()\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.calculate_moments_of_inertia","title":"<code>calculate_moments_of_inertia()</code>","text":"<p>Computes the moments of inertia of system in the body frame.</p> <p>Returns:</p> Type Description <code>    I_rotated: 3x3 numpy array</code> <p>Inertia tensor in the rotated frame.</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def calculate_moments_of_inertia(self):\n    \"\"\"\n    Computes the moments of inertia of system in the body frame.\n\n    Parameters\n    ----------\n        R: 3x3 numpy array\n            Rotation matrix from parafoil frame to body frame.\n\n    Returns\n    -------\n        I_rotated: 3x3 numpy array\n            Inertia tensor in the rotated frame.\n    \"\"\"\n    # Principle moments of inertia of the parafoil\n    Ix_parafoil = 1.0\n    Iy_parafoil = 2.0\n    Iz_parafoil = 3.0\n    # Rotation matrix from parafoil frame to body frame\n    R = np.array([\n        [np.cos(self.rigging_angle), 0, np.sin(self.rigging_angle)],\n        [0, 1, 0],\n        [-np.sin(self.rigging_angle), 0, np.cos(self.rigging_angle)]\n    ])\n\n    # Principle inertia tensor\n    I_parafoil = np.diag([Ix_parafoil, Iy_parafoil, Iz_parafoil])\n\n    # Rotate into the new frame\n    I_rotated_parafoil = R @ I_parafoil @ R.T\n\n    # ___________ payload moment of inertia _____________\n\n    # define the inertia tensor of the payload, atm assume to be cylindrical\n    Ix_payload = 0.1\n    Iy_payload = 0.1\n    Iz_payload = 0.1\n\n    # principle inertia tensor of the payload\n    I_payload = np.diag([Ix_payload, Iy_payload, Iz_payload])\n\n    # ___________ Inertias at coM  _____________\n    # calculate the inertia tensor at the center of mass\n    # CoM of the system assumed to be at coM of Payload\n    # use parallel axis theorem to represent parafoil tensor at coM of system\n\n    # distance between parafoil and payload\n    d = np.array([0, 0, self.Rp])\n    d_outer = np.outer(d, d)\n    I_parafoil_at_com = I_rotated_parafoil + self.parafoil_mass * ((np.dot(d, d) * np.eye(3)) - d_outer)\n\n    # calculate the inertia tensor at the center of mass\n    self.I = I_parafoil_at_com + I_payload\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.check_set_param","title":"<code>check_set_param(dict, param_name)</code>","text":"<p>Check if the parameter is set in the dictionary and if its type matches the expected type. If so, sets the instance variable self. to the value from the dictionary. Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def check_set_param(self, dict, param_name):\n    \"\"\"\n    Check if the parameter is set in the dictionary and if its type matches the expected type.\n    If so, sets the instance variable self.&lt;attr_name&gt; to the value from the dictionary.\n    \"\"\"\n    param = dict.get(param_name)\n    if param is None:\n        return False\n    elif not hasattr(self, param_name):\n        raise AttributeError(f\"Attribute '{param_name}' does not exist on the instance.\")\n    elif type(getattr(self, param_name)) != type(param):\n        raise TypeError(f\"Parameter '{param_name}' should be of type {type(getattr(self, param_name))}. Got {type(param)} instead.\")\n\n    setattr(self, param_name, param)\n\n    # print(f\"Set {param_name} to {param}\")\n    return True\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.get_CDM","title":"<code>get_CDM(euler_angles=None)</code>","text":"<p>Get the rotation matrix from body to inertial frame</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def get_CDM(self, euler_angles = None):\n    \"\"\"\n    Get the rotation matrix from body to inertial frame\"\"\"\n    if euler_angles is None:\n        phi, theta, psi = self.eulers\n    else:\n        phi, theta, psi = euler_angles\n    return np.array([\n    [np.cos(theta) * np.cos(psi), np.sin(phi) * np.sin(theta) * np.cos(psi) - np.cos(phi) * np.sin(psi), np.cos(phi) * np.sin(theta) * np.cos(psi) + np.sin(phi) * np.sin(psi)],\n    [np.cos(theta) * np.sin(psi), np.sin(phi) * np.sin(theta) * np.sin(psi) + np.cos(phi) * np.cos(psi), np.cos(phi) * np.sin(theta) * np.sin(psi) - np.sin(phi) * np.cos(psi)],\n    [-np.sin(theta), np.sin(phi) * np.cos(theta), np.cos(phi) * np.cos(theta)]\n    ])\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.get_angular_vel_skew","title":"<code>get_angular_vel_skew(angular_vel=None)</code>","text":"<p>Get the skew symmetric matrix of the angular velocity vector.</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def get_angular_vel_skew(self, angular_vel = None):\n    \"\"\"\n    Get the skew symmetric matrix of the angular velocity vector.\n    \"\"\"\n    if angular_vel is None:\n        p, q, r = self.angular_vel\n    else:\n        p, q, r = angular_vel\n    return np.array([\n        [0, -r, q],\n        [r, 0, -p],\n        [-q, p, 0]\n    ])\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.get_angular_vel_to_EulerRates_matrix","title":"<code>get_angular_vel_to_EulerRates_matrix(euler_angles=None)</code>","text":"<p>Get the transformation matrix from angular velocity to euler rates.</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def get_angular_vel_to_EulerRates_matrix(self, euler_angles = None):\n    \"\"\"\n    Get the transformation matrix from angular velocity to euler rates.\n    \"\"\"\n    if euler_angles is None:\n        phi, theta, psi = self.eulers\n    else:\n        phi, theta, psi = euler_angles\n    if abs(theta - np.pi/2) &lt; 0.1:\n        self.error = True\n        # print(\"theta is close to 90.\")\n        theta = np.pi/2 * 0.999\n    return np.array([\n        [1, np.sin(phi) * np.tan(theta), np.cos(phi) * np.tan(theta)],\n        [0, np.cos(phi), -np.sin(phi)],\n        [0, np.sin(phi) / np.cos(theta), np.cos(phi) / np.cos(theta)]\n    ])\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.get_euler_rates","title":"<code>get_euler_rates(angular_vel=None)</code>","text":"<p>Get the euler rates from the angular velocity vector.</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def get_euler_rates(self, angular_vel = None):\n    \"\"\"\n    Get the euler rates from the angular velocity vector.\n    \"\"\"\n    if angular_vel is None:\n        angular_vel = self.angular_vel\n    return np.dot(self.T_angularVel_to_EulerRates, angular_vel)\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.get_state","title":"<code>get_state()</code>","text":"<p>Get the current state vector.</p> <p>Returns:</p> Type Description <code>list</code> <p>[position, velocity_body, eulers, angular_velocity].</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def get_state(self):\n    \"\"\"\n    Get the current state vector.\n\n    Returns\n    -------\n    list\n        [position, velocity_body, eulers, angular_velocity].\n    \"\"\"\n    return [self.p, self.vb, self.eulers, self.angular_vel]\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.safe_clamp_vector","title":"<code>safe_clamp_vector(vec, max_abs=1000.0)</code>","text":"<p>Clamp a 3D vector to avoid NaN, inf, and excessively large values.</p> <p>Returns:</p> Type Description <code>    np.ndarray: A safe, clamped 3D vector.</code> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def safe_clamp_vector(self, vec, max_abs=1e3):\n    \"\"\"\n    Clamp a 3D vector to avoid NaN, inf, and excessively large values.\n\n    Parameters\n    ----------\n        vec (np.ndarray): Input 3D vector.\n        max_abs (float): Maximum allowed absolute value for each component.\n\n    Returns\n    -------\n        np.ndarray: A safe, clamped 3D vector.\n    \"\"\"\n    safe_vec = np.zeros(3)\n\n    for i in range(3):\n        val = vec[i]\n        if not np.isfinite(val):\n            #print(\"clamping\")\n            self.error = True\n            safe_vec[i] = 0.0\n        elif abs(val) &gt; max_abs:\n            #print()\n            self.error = True\n            safe_vec[i] = np.clip(val, -max_abs, max_abs)\n        else:\n            safe_vec[i] = val\n\n    return safe_vec\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.set_actual_flaps","title":"<code>set_actual_flaps(input)</code>","text":"<p>Set both actual and desired flap deflections.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>tuple of float</code> <p>Left and right flap deflections (radians).</p> required Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def set_actual_flaps(self, input):\n    \"\"\"\n    Set both actual and desired flap deflections.\n\n    Parameters\n    ----------\n    input : tuple of float\n        Left and right flap deflections (radians).\n    \"\"\"\n\n    self.flap_l,self.flap_r = input\n    self.flap_l_desired,self.flap_r_desired = input\n    self.update_flaps(1) # doesnt matter, they be the same\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.set_coefficients","title":"<code>set_coefficients(coefficients=None)</code>","text":"<p>Set the aerodynamic coefficients for the simulation. Accepts either a list (in predefined order) or a dictionary (by name).</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def set_coefficients(self, coefficients=None):\n    \"\"\"\n    Set the aerodynamic coefficients for the simulation.\n    Accepts either a list (in predefined order) or a dictionary (by name).\n    \"\"\"\n    if coefficients is None:\n        return\n\n    # Handle dictionary input\n    if isinstance(coefficients, dict):\n        for name in [\n            \"CDo\", \"CDa\", \"CD_sym\", \"CLo\", \"CLa\", \"CL_sym\",\n            \"CYB\", \"ClB\", \"Clp\", \"Clr\", \"Cl_asym\", \"Cmo\",\n            \"Cma\", \"Cmq\", \"CnB\", \"Cn_p\", \"Cn_r\", \"Cn_asym\"\n        ]:\n            if name in coefficients:\n                setattr(self, name, coefficients[name])\n        return\n\n    # Handle list input\n    if isinstance(coefficients, list) or isinstance(coefficients, tuple):\n        if len(coefficients) &lt; 18:\n            raise ValueError(\"Coefficient list must have at least 18 values.\")\n        (\n            self.CDo, self.CDa, self.CD_sym,\n            self.CLo, self.CLa, self.CL_sym,\n            self.CYB, self.ClB, self.Clp, self.Clr, self.Cl_asym,\n            self.Cmo, self.Cma, self.Cmq,\n            self.CnB, self.Cn_p, self.Cn_r, self.Cn_asym\n        ) = coefficients\n        return\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.set_desired_flaps","title":"<code>set_desired_flaps(input)</code>","text":"<p>Set desired flap deflections.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>tuple of float</code> <p>Desired left and right flap deflections (radians).</p> required Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def set_desired_flaps(self, input):\n    \"\"\"\n    Set desired flap deflections.\n\n    Parameters\n    ----------\n    input : tuple of float\n        Desired left and right flap deflections (radians).\n    \"\"\"\n\n    self.flap_l_desired,self.flap_r_desired = input\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.set_inputs","title":"<code>set_inputs(inputs)</code>","text":"<p>Set the inputs for the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>list</code> <p>A list containing: - input[0]: Tuple[float, float], flap deflection angles (left, right). - input[1]: np.ndarray, wind vector in the inertial frame.</p> required Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def set_inputs(self,inputs):\n    \"\"\"\n    Set the inputs for the simulation.\n\n    Parameters\n    ----------\n    inputs : list\n        A list containing:\n        - input[0]: Tuple[float, float], flap deflection angles (left, right).\n        - input[1]: np.ndarray, wind vector in the inertial frame.\n    \"\"\"\n    self.set_actual_flaps(inputs[0])\n    self.w = inputs[1] # wind vector in inertial frame\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.set_system_params","title":"<code>set_system_params(system_params)</code>","text":"<p>Set the system parameters for the simulation. Default values follow Snowflake PAD model.</p> <p>see: Yakimenko, Oleg A.. (2015). Precision Aerial Delivery Systems - Modeling, Dynamics, and Control <pre><code>    Parameters\n</code></pre> <p>params : dict     Keys must include:     - m : float, mass [kg]     - b : float, span [m]     - S : float, area [m^2]     - c : float, chord [m]     - x_cg : float, CG x-location [m]     - z_cg : float, CG z-location [m]     - Ixx, Iyy, Izz, Ixz : float, inertia terms     - flap_time_constant : float, flap actuator time constant     - C_* : float, aerodynamic coefficients</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def set_system_params(self,system_params):\n    \"\"\"\n    Set the system parameters for the simulation. Default values follow Snowflake PAD model.\n\n    see: Yakimenko, Oleg A.. (2015). &lt;i&gt;Precision Aerial Delivery Systems - Modeling, Dynamics, and Control\n\n            Parameters\n    ----------\n    params : dict\n        Keys must include:\n        - m : float, mass [kg]\n        - b : float, span [m]\n        - S : float, area [m^2]\n        - c : float, chord [m]\n        - x_cg : float, CG x-location [m]\n        - z_cg : float, CG z-location [m]\n        - Ixx, Iyy, Izz, Ixz : float, inertia terms\n        - flap_time_constant : float, flap actuator time constant\n        - C_* : float, aerodynamic coefficients\n    \"\"\"\n    # ------------------- simulation params --------------\n    self.dt = 0.1\n    self.check_set_param(system_params, \"dt\")\n\n    # -------------------- parafoil params\n\n    # aerodynamic parameters, default values follow Snowflake PAD model.\n    self.S = 1.0\n    self.check_set_param(system_params, \"S\") # surface area of parafoil\n    self.c = 0.75\n    self.check_set_param(system_params, \"c\") # mean chord length\n    #self.AR = 0.0\n    #self.check_set_param(system_params, self.AR, \"AR\") # aspect ratio\n    self.t = 0.075\n    self.check_set_param(system_params, \"t\") # thickness of the parafoil\n    self.b = 1.35\n    self.check_set_param(system_params, \"b\") # wingspan of the parafoil\n    self.rigging_angle = np.radians(-12.0)\n    self.check_set_param(system_params, \"rigging_angle\")\n\n    # system parameters\n    self.m = 2.4 # mass of the system\n    self.check_set_param(system_params, \"m\") # mass of the system\n    self.Rp = np.array([0.0,0,-1.11]) # distance between parafoil and the center of mass for the system\n\n\n    self.check_set_param(system_params, \"Rp\")\n\n    self.I = np.array([[0.42,0,0.03],[0,0.4,0],[0.03,0,0.053]]) # moment of inertia of the system\n    # if we have to do our own calculations, we need more info\n    self.check_set_param(system_params, \"I\") # moment of inertia of the system\n\n\n    self.initial_pos = [0,0,0] # initial position of the system in inertial frame\n    self.check_set_param(system_params, \"initial_pos\")\n\n    self.flap_time_constant = 1 # number of seconds to go from 0 flap to max flap\n    self.check_set_param(system_params, \"flap_time_constant\")\n\n    \"\"\"\"\n    self.parafoil_mass = 0.0\n    self.check_set_param(system_params,self.parafoil_mass, \"parafoil_mass\") # mass of parafoil\n    self.payload_mass = 0.0\n    self.check_set_param(system_params,self.payload_mass, \"payload_mass\") # mass of payload\n    self.Rlc = 0.0\n    self.check_set_param(system_params,self.Rlc, \"Rlc\") # distance between payload CoM and connection point to parafoil\n    self.Rpc = 0.0\n    self.check_set_param(system_params,self.Rpc, \"Rpc\") # distance between parafoil CoM and connection point to parafoil\n\n    self.m = self.parafoil_mass + self.payload_mass # mass of entire system\n\n    \"\"\"\n\n    # ________________ aerodynamic parameters ____________________\n    # for drag\n    self.CD = 0\n    self.CDo = 0.25\n    self.check_set_param(system_params, \"CDo\")\n    self.CDa = 0.12\n    self.check_set_param(system_params, \"CDa\") # drag coefficient\n    self.CD_sym = 0.2\n    self.check_set_param(system_params, \"CD_sym\")\n\n    # for lift\n    self.CL = 0\n    self.CLo = 0.091\n    self.check_set_param(system_params, \"CL\") # lift coefficient\n    self.CLa = 0.90\n    self.check_set_param(system_params, \"CLa\") # lift coefficient changing due to angle of incidance\n    self.CL_sym = 0.2\n    self.check_set_param(system_params, \"CL_sym\") # lift coefficient changing due to angle of incidance\n\n    # for side force\n    self.CYB = -0.23\n    self.check_set_param(system_params, \"CYB\") # side force coefficient\n\n    # for rolling\n    self.Cl = 0\n    self.ClB = -0.036 # coefficient due to sideslip angle\n    self.check_set_param(system_params, \"clB\")\n    self.Clp = -0.84\n    self.check_set_param(system_params,\"Clp\")\n    self.Clr = -0.082\n    self.check_set_param(system_params,\"Clr\")\n    self.Cl_asym = -0.0035 # coefficient due to asymmetric flap deflection\n    self.check_set_param(system_params, \"Cl_asym\")\n\n    # for pitching\n    self.Cm = 0\n    self.Cmo = 0.35 # coefficient at zero lift\n    self.check_set_param(system_params, \"Cmo\")\n    self.Cma = -0.72 # coefficient due to angle of incidance\n    self.check_set_param(system_params, \"Cma\")\n    self.Cmq = -1.49\n    self.check_set_param(system_params, \"Cmq\") # coefficient due to pitch rate\n\n    # for yawing\n    self.Cn = 0\n    self.CnB = -0.0015 # coefficient due to sideslip angle\n    self.check_set_param(system_params, \"CnB\")\n    self.Cn_p = -0.082 # coefficient due to roll rate\n    self.check_set_param(system_params, \"Cn_p\")\n    self.Cn_r = -0.27\n    self.check_set_param(system_params, \"Cn_r\") # coefficient due to yaw rate\n    self.Cn_asym = 0.0115\n    self.check_set_param(system_params, \"Cn_asym\") # coefficient due to asymmetric flap deflection           \n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.update_flaps","title":"<code>update_flaps(dt)</code>","text":"<p>Update flap positions based on the desired values and rate limits.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>Time step (seconds).</p> required Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def update_flaps(self,dt):\n    \"\"\"\n    Update flap positions based on the desired values and rate limits.\n\n    Parameters\n    ----------\n    dt : float\n        Time step (seconds).\n    \"\"\"\n    max_rate = dt/self.flap_time_constant\n    self.flap_l += np.clip(self.flap_l_desired - self.flap_l, -max_rate, max_rate) \n    self.flap_r += np.clip(self.flap_r_desired - self.flap_r, -max_rate, max_rate) \n    # calculate the flap deflection angles\n    self.delta_a = self.flap_r - self.flap_l  # asymmetric flap deflection\n    self.delta_s = 0.5*(self.flap_l + self.flap_r) # symmetric flap deflection\n</code></pre>"},{"location":"api/#minos.six_DoF_simulator.ParafoilSimulation_6Dof.update_kinematic_transforations","title":"<code>update_kinematic_transforations(euler_angles=None, angular_vel=None)</code>","text":"<p>Update the kinematic transformations based on the current state.</p> Source code in <code>src\\minos\\six_DoF_simulator.py</code> <pre><code>def update_kinematic_transforations(self, euler_angles = None, angular_vel = None):\n    \"\"\"\n    Update the kinematic transformations based on the current state.\n    \"\"\"\n    if euler_angles is None:\n        euler_angles = self.eulers\n    if angular_vel is None:\n        angular_vel = self.angular_vel\n    self.CDM = self.get_CDM(euler_angles)\n    self.angular_vel_skew = self.get_angular_vel_skew(angular_vel)\n    self.T_angularVel_to_EulerRates = self.get_angular_vel_to_EulerRates_matrix(euler_angles)\n</code></pre>"}]}