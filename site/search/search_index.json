{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Minos","text":"<p>Minos is a parafoil simulation and guidance research project built around a modular architecture:</p> <ul> <li><code>minos.physics</code> for 6-DoF plant dynamics,</li> <li><code>minos.gnc</code> for navigation, guidance, and control strategies,</li> <li><code>minos.sim.runners</code> for canonical open-loop and closed-loop execution loops,</li> <li><code>minos.identification</code> for aerodynamic coefficient fitting workflows.</li> <li><code>minos.parallel</code> for reusable sequential/thread/process task execution.</li> </ul> <p>The project is organized to support repeatable strategy comparison:</p> <ol> <li>Keep one shared physics model.</li> <li>Swap GnC components via interfaces.</li> <li>Run both through the same simulation runner layer.</li> <li>Compare behavior using common snapshot logging and plotting utilities.</li> </ol> <p>If you are new to the repo, start with:</p> <ol> <li><code>usage.md</code> for setup and first runs.</li> <li><code>architecture.md</code> for how modules fit together.</li> <li><code>examples.md</code> for runnable scenarios.</li> </ol>"},{"location":"#why","title":"Why?","text":"<p>You might ask why I did this project and I would tell you there are two reasons. Firstly, and the problem aimed to be solved, model rockets very often like to drift with the wind once the parachute opens. The pesky things then drift for miles and often end up in trees so what a better way to prevent this then just swap the simple parachute for a super complicated control system and tangle loving parafoil. Secondly, and the reason I ended up doing this physics/areodynamicist/compsci project as a electronic student was low and behold, no one else in the team wanted to do simulation.</p> <p>Apparently you cannot do any acidemic engineering projects without simulation? That and we thought there wouldn't be enough work for 5 students (there definitely was) so the simulation can of worms was opened and politely handed to me. Anyways, I digress. I knew right from the start that this would be an absolute ball ache and I was not wrong.</p>"},{"location":"#my-take-on-minos","title":"My take on Minos","text":"<p>Overall though, a super fun project and I was happy to fit in some genetic algorithmns in for model Identifion. This was by far the most interesting part, even tho most of that work was done 3 days before the deadline. Guidance is very interesting and there is soooo much more scope then I did for minos (dont copy Minos guidance, it is subpar).</p> <p>Physics models are hard. Coding them in are just as bad. Realistically, the work in Minos is a generic 6D0F model, it doesnt at all consider the rocket and its long pedulmn shape. Not at all realistic for tuning control algorithmns which is what the aim of Minos was.</p> <p>If you enjoy life (well I guess you are reading this so clearly there are some doubts), stick to normal parachutes and go launch some rockets. check out LURA.</p>"},{"location":"#tyler-please-can-i-read-your-dissatation","title":"Tyler, please can I read your dissatation?","text":"<p>Nice try good sir, fortuantely there are books and papers which do a far better job  at everything then the 30 page sleepless mess that I unconsiously produced during a blur of academic overloading. If I was good boy in finishing this documentation, I will have copied over some parts for explinations for specific features or concepts. Instead I will list some stupendus references that were odanied bibles during the project tenure. (TLDR No feck off, read shite)</p>"},{"location":"architecture/","title":"Architecture Overview","text":""},{"location":"architecture/#goal","title":"Goal","text":"<p>The repository is structured to compare guidance/control strategies under a shared physics plant with minimal coupling between layers.</p>"},{"location":"architecture/#core-modules","title":"Core modules","text":"<ul> <li><code>minos.physics</code></li> <li>6-DoF parafoil plant model.</li> <li><code>minos.gnc</code></li> <li>modular navigation, guidance, and control interfaces + implementations.</li> <li><code>minos.sim.runners</code></li> <li>canonical simulation orchestration layer.</li> <li><code>minos.identification</code></li> <li>coefficient identification and GA-based fitting workflows.</li> <li><code>minos.utilities</code></li> <li>plotting, visualization, and snapshot helpers.</li> </ul>"},{"location":"architecture/#layer-responsibilities","title":"Layer responsibilities","text":"<ol> <li>Physics computes state evolution from inputs.</li> <li>GnC computes inputs from observations.</li> <li>Simulation runners connect physics and GnC at runtime.</li> <li>Utilities consume snapshot outputs for analysis.</li> </ol>"},{"location":"architecture/#closed-loop-flow","title":"Closed-loop flow","text":"<ol> <li>Read simulator state and diagnostics.</li> <li>Build <code>Observation</code>.</li> <li>Run <code>GncStack.update(observation, dt)</code>.</li> <li>Apply returned <code>Inputs</code> to the physics model.</li> <li>Step plant and log <code>SimulationSnapshot</code>.</li> </ol>"},{"location":"architecture/#open-loop-flow","title":"Open-loop flow","text":"<ol> <li>Provide flap and wind schedules.</li> <li>Runner applies schedule values each time step.</li> <li>Plant advances and snapshots are logged.</li> </ol>"},{"location":"architecture/#why-this-structure","title":"Why this structure","text":"<ul> <li>Strategy comparison remains fair because plant and runner are fixed.</li> <li>New GnC methods can be added without physics edits.</li> <li>Identification pipelines can reuse the same simulation layer.</li> </ul>"},{"location":"documentation/","title":"Documentation","text":"<p>Use these commands from the repository root to build and serve the MkDocs site.</p>"},{"location":"documentation/#generate-docs-build-static-site","title":"Generate docs (build static site)","text":"<pre><code>poetry run mkdocs build\n</code></pre> <p>Generated output is written to <code>site/</code>.</p>"},{"location":"documentation/#serve-docs-locally-with-live-reload","title":"Serve docs locally (with live reload)","text":"<pre><code>poetry run mkdocs serve\n</code></pre> <p>Then open <code>http://127.0.0.1:8000/</code>.</p>"},{"location":"documentation/#optional-clean-build-serve","title":"Optional: clean build + serve","text":"<pre><code>poetry run mkdocs build --clean\npoetry run mkdocs serve\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#recommended-examples","title":"Recommended examples","text":""},{"location":"examples/#examplesphysics_model_3d_examplepy","title":"<code>examples/physics_model_3d_example.py</code>","text":"<p>Open-loop physics demonstration:</p> <ul> <li>builds a simple flap/wind schedule,</li> <li>runs <code>simulate_model</code>,</li> <li>plots selected channels,</li> <li>renders interactive 3D motion.</li> </ul>"},{"location":"examples/#examplesgnc_3d_examplepy","title":"<code>examples/gnc_3d_example.py</code>","text":"<p>Closed-loop modular GnC demonstration:</p> <ul> <li>builds <code>ParafoilModel6DOF</code>,</li> <li>builds <code>GncStack</code> (<code>Navigator</code> + <code>GuidanceLaw</code> + <code>Controller</code>),</li> <li>runs <code>run_simulation_with_gnc</code>,</li> <li>plots diagnostics and headings,</li> <li>renders 3D motion.</li> </ul> <p>Headless mode:</p> <pre><code>poetry run python examples/gnc_3d_example.py --no-show\n</code></pre>"},{"location":"examples/#examplesgnc_t_approach_2_examplepy","title":"<code>examples/gnc_t_approach_2_example.py</code>","text":"<p>Closed-loop run using the pseudocode-driven <code>TApproachGuidance2</code> mode machine. Prints run metrics (landing error, heading RMSE, control effort, wind estimate error).</p>"},{"location":"examples/#examplesgnc_metrics_examplepy","title":"<code>examples/gnc_metrics_example.py</code>","text":"<p>Scenario-based GnC metric evaluation:</p> <ul> <li>executes multiple method variants on the same scenario,</li> <li>computes per-run + aggregate metrics,</li> <li>writes <code>gnc_metrics_report.json</code>.</li> </ul>"},{"location":"examples/#examplesidentification_metrics_examplepy","title":"<code>examples/identification_metrics_example.py</code>","text":"<p>Shows shared trajectory metrics in the identification evaluator path (RMSE/P95 + penalty factor).</p>"},{"location":"examples/#examplesparallel_gnc_pid_step_sweeppy","title":"<code>examples/parallel_gnc_pid_step_sweep.py</code>","text":"<p>Parallel PID gain sweep for steering-only step-response tests:</p> <ul> <li>no wind,</li> <li>left/right 90-degree heading maneuvers,</li> <li>prints best gains and plots desired vs actual heading.</li> </ul>"},{"location":"examples/#how-to-use-examples-for-development","title":"How to use examples for development","text":"<ol> <li>Start from the closest example.</li> <li>Change only scenario parameters first (wind, initial conditions, target).</li> <li>Then swap GnC components if needed.</li> <li>Keep output snapshots and plot selections consistent for fair comparison.</li> </ol>"},{"location":"guidance/","title":"Guidance, Navigation, and Control (GnC)","text":""},{"location":"guidance/#introduction","title":"Introduction","text":"<p>Parafoil GnC sits at the intersection of path planning, wind-aware guidance, and low-level actuation under strong model uncertainty. Unlike many fixed-wing systems, parafoils are highly wind sensitive, have limited control authority (typically brake/flap asymmetry and symmetry), and often operate in terminal descent conditions where timing and geometry are tightly coupled.</p> <p>In the broader field, parafoil guidance strategies commonly combine:</p> <ul> <li>phase-based mission logic (for example initialization, homing, energy   management, final approach),</li> <li>online wind estimation from inertial motion,</li> <li>and heading tracking control mapped into asymmetric flap/brake commands.</li> </ul> <p>The practical challenge is not only designing each algorithm, but integrating them so strategies can be swapped and compared fairly against the same physics plant and scenario conditions.</p> <p>This project\u2019s GnC architecture is designed for that comparison workflow.</p>"},{"location":"guidance/#purpose","title":"Purpose","text":"<p>The GnC layer produces plant inputs from observed vehicle behavior.</p> <ul> <li>Input: current simulation observation (<code>state</code>, inertial kinematics, wind,   rates, time).</li> <li>Output: flap commands (and selected wind signal usage) packaged as physics   <code>Inputs</code>.</li> </ul> <p>The key design goal is modular strategy composition:</p> <ul> <li>navigation is replaceable,</li> <li>guidance is replaceable,</li> <li>control is replaceable,</li> <li>orchestration is consistent.</li> </ul>"},{"location":"guidance/#system-layout","title":"System Layout","text":""},{"location":"guidance/#1-gnc-interfaces-minosgncinterfaces","title":"1) GnC interfaces (<code>minos.gnc.interfaces</code>)","text":"<p>Core contracts define component boundaries:</p> <ul> <li><code>Navigator</code></li> <li><code>GuidanceLaw</code></li> <li><code>Controller</code></li> <li>optional <code>PhaseManager</code></li> </ul> <p>Shared typed payloads:</p> <ul> <li><code>Observation</code></li> <li><code>NavigationEstimate</code></li> <li><code>GuidanceCommand</code></li> <li><code>ControlCommand</code></li> <li><code>MissionContext</code></li> </ul> <p>These contracts are the stable integration surface for new strategies.</p>"},{"location":"guidance/#2-gnc-orchestration-minosgncstack","title":"2) GnC orchestration (<code>minos.gnc.stack</code>)","text":"<p><code>GncStack</code> executes one closed-loop cycle:</p> <ol> <li>navigation update,</li> <li>optional phase update,</li> <li>guidance update,</li> <li>controller update,</li> <li>command validation/clipping,</li> <li>return plant <code>Inputs</code>.</li> </ol> <p><code>GncStackConfig</code> controls cross-cutting behavior such as flap limits and wind source selection.</p>"},{"location":"guidance/#3-current-strategy-set-minosgnc","title":"3) Current strategy set (<code>minos.gnc.*</code>)","text":"<ul> <li>Navigation:</li> <li><code>navigation/wind_estimator_rls.py</code> (<code>RlsWindEstimator</code>)</li> <li>Guidance:</li> <li><code>guidance/t_approach.py</code> (<code>TApproachGuidance</code>)</li> <li><code>guidance/t_approach_2.py</code> (<code>TApproachGuidance2</code>)</li> <li><code>guidance/timed_heading_sequence.py</code> (<code>TimedHeadingSequenceGuidance</code>)</li> <li>Control:</li> <li><code>control/pid_heading.py</code> (<code>PidHeadingController</code>)</li> <li>Adapters:</li> <li><code>adapters/from_sim.py</code> (<code>observation_from_sim</code>)</li> </ul>"},{"location":"guidance/#how-gnc-connects-to-physics","title":"How GnC Connects to Physics","text":"<p>The physics model (<code>minos.physics</code>) remains the plant and does not embed control policy.</p> <p>Closed-loop execution is handled in <code>minos.sim.runners.run_simulation_with_gnc</code>:</p> <ol> <li>Read plant state/diagnostics.</li> <li>Build <code>Observation</code>.</li> <li>Run <code>GncStack.update(observation, dt)</code>.</li> <li>Apply returned <code>Inputs</code> to <code>ParafoilModel6DOF</code>.</li> <li>Step physics and log <code>SimulationSnapshot</code>.</li> </ol> <p>This separation keeps strategy logic out of plant dynamics and makes A/B testing of GnC variants straightforward.</p>"},{"location":"guidance/#wind-estimation-in-the-loop","title":"Wind Estimation in the Loop","text":"<p>Wind estimation belongs to the navigation layer.</p> <ul> <li><code>RlsWindEstimator</code> estimates horizontal wind from observed inertial velocity.</li> <li>Guidance consumes the estimate for path geometry decisions.</li> <li>Controller consumes guidance commands (and current rates) to generate flaps.</li> </ul> <p>By default, the closed-loop runner keeps plant wind as scenario truth while GnC uses estimated wind internally. This preserves realistic estimation error during evaluation.</p>"},{"location":"guidance/#metrics-and-benchmarking","title":"Metrics and Benchmarking","text":"<p>Recent additions provide machine-readable GnC metrics and benchmarking helpers:</p> <ul> <li><code>minos.gnc.metrics</code></li> <li><code>compute_run_metrics</code></li> <li><code>aggregate_metrics</code></li> <li><code>minos.gnc.benchmark</code></li> <li><code>ScenarioConfig</code></li> <li><code>run_benchmark_scenario</code></li> <li><code>run_benchmark_suite</code></li> </ul> <p>These are intended for fair A/B comparison across guidance/controller variants using the same plant and scenario definitions.</p> <p>Snapshot logs now also carry GnC telemetry useful for analysis:</p> <ul> <li>mission phase,</li> <li>flare command,</li> <li>estimated wind,</li> <li>raw vs clipped flap commands.</li> </ul>"},{"location":"guidance/#what-to-change-for-new-gnc-experiments","title":"What To Change For New GnC Experiments","text":"<ul> <li>New estimator:</li> <li>add a <code>Navigator</code> implementation under <code>minos.gnc.navigation</code>.</li> <li>New guidance law:</li> <li>add a <code>GuidanceLaw</code> implementation under <code>minos.gnc.guidance</code>.</li> <li>New control law:</li> <li>add a <code>Controller</code> implementation under <code>minos.gnc.control</code>.</li> <li>New mission phase logic:</li> <li>add a <code>PhaseManager</code> and wire it into <code>GncStack</code>.</li> </ul> <p>Use the same runner and physics plant to keep comparisons fair.</p>"},{"location":"guidance/#examples","title":"Examples","text":"<ul> <li>Closed-loop modular GnC example:</li> <li><code>examples/gnc_3d_example.py</code></li> <li>Open-loop physics baseline:</li> <li><code>examples/physics_model_3d_example.py</code></li> </ul> <p>These examples are the recommended entry points for extending GnC behavior.</p>"},{"location":"identification/","title":"Physics Model identification","text":""},{"location":"identification/#introduction","title":"Introduction","text":"<p>The refactored identification flow provides a typed, modular stack in <code>minos.identification</code>:</p> <ul> <li><code>FlightDataset</code>: validated measured data container.</li> <li><code>TrajectoryEvaluator</code>: computes trajectory objective cost using the refactored physics simulator.</li> <li><code>optimize_coefficients_ga</code>: DEAP-based optimizer decoupled from simulation internals.</li> <li><code>run_position_identification_ga</code>: high-level runner for position-based fitting.</li> </ul> <p>This lets old script workflows remain in place while enabling incremental migration to modular code.</p> <p>The evaluator now exposes shared trajectory error metrics (<code>rmse</code>, <code>mae</code>, <code>p95</code>, final error) through <code>EvaluationResult.position_metrics</code>, while keeping the existing scalar <code>cost</code> contract for GA compatibility.</p>"},{"location":"identification/#design-rationale","title":"Design Rationale","text":"<p>The code is structured this way to keep runtime-heavy experiments manageable and to avoid silent mismatches between optimization workflows and the simulation plant.</p> <ol> <li>Single coefficient order source:    <code>CoefficientCodec</code> uses <code>AeroCoefficients.ORDER</code> directly, so coefficient    vectors used by GA always map to the same names used by physics.</li> <li>Typed dataset boundary:    <code>FlightDataset</code> validates shapes once and exposes a simulation-input adapter.    This prevents repeated shape checks and reduces per-evaluation overhead.</li> <li>Separation of responsibilities:    <code>TrajectoryEvaluator</code> owns objective math and simulation calls.    <code>deap_ga</code> owns search logic.    Experiment scripts only define scenario-specific data and outputs.</li> <li>Compute-aware defaults:    GA supports parallel evaluation and multi-fidelity (coarse-to-fine) scoring.    This keeps long runs practical without changing physics equations.</li> </ol>"},{"location":"identification/#runtime-reduction-features","title":"Runtime Reduction Features","text":"<p>The optimizer includes two built-in runtime controls:</p> <ol> <li>Parallel fitness evaluation:    Set <code>GAConfig.n_jobs</code>.    <code>1</code> means serial, <code>0</code> means auto (<code>cpu_count - 1</code>), and values <code>&gt;1</code> set    explicit worker count.</li> <li>Multi-fidelity evaluation:    Enable with <code>GAConfig.enable_multi_fidelity=True</code> and tune:    <code>coarse_stride</code>, <code>coarse_until_fraction</code>, and <code>coarse_top_k_full</code>.    Early generations run on downsampled trajectories and top candidates are    re-scored at full fidelity to keep ranking quality.</li> </ol> <p>Example:</p> <pre><code>import numpy as np\nfrom minos.identification import FlightDataset, GAConfig, run_position_identification_ga\n\ndataset = FlightDataset(\n    time_s=time_s,\n    flap_left=flap_left,\n    flap_right=flap_right,\n    wind_inertial=wind,\n    measured_positions=measured_positions,\n)\n\nresult = run_position_identification_ga(\n    dataset,\n    params={\"initial_pos\": [0.0, 0.0, 500.0]},\n    initial_conditions=initial_conditions,\n    optimize_names=[\"CDo\", \"CDa\", \"CLo\", \"CLa\"],\n    ga_config=GAConfig(population_size=30, generations=100, seed=7),\n)\n</code></pre>"},{"location":"identification/#experiment-scripts","title":"Experiment Scripts","text":"<p>Three scripts are maintained as concrete experiment entry points:</p> <ol> <li><code>src/minos/identification/Simple_GA.py</code>    Full coefficient vector optimization in one run.</li> <li><code>src/minos/identification/mod_v2.py</code>    Group-focused optimization for a selected coefficient subset.</li> <li><code>src/minos/identification/TSGA_modified.py</code>    Sequential grouped optimization where later groups start from earlier updates.</li> </ol> <p>All three scripts share the same evaluator and GA core, which keeps behavior consistent and easier to benchmark.</p>"},{"location":"identification/#tsga-api-reference","title":"TSGA API reference","text":"<p>Stepwise grouped GA coefficient identification.</p> <p>This replaces the legacy TSGA_modified script with the refactored identification stack.</p>"},{"location":"identification/#minos.identification.TSGA_modified.optimize_group","title":"<code>optimize_group(names, dataset, base_coefficients, seed)</code>","text":"<p>Optimize one group using current best values as fixed context.</p> Source code in <code>src\\minos\\identification\\TSGA_modified.py</code> <pre><code>def optimize_group(\n    names: list[str],\n    dataset: FlightDataset,\n    base_coefficients: dict[str, float],\n    seed: int,\n) -&gt; dict[str, object]:\n    \"\"\"Optimize one group using current best values as fixed context.\"\"\"\n    bounds = CoefficientBounds(by_name=bounds_dict)\n    evaluator = TrajectoryEvaluator(\n        dataset=dataset,\n        params=PARAMS,\n        initial_conditions=INITIAL_CONDITIONS,\n        inertial=True,\n        break_penalty_scale=1.0,\n    )\n\n    result = optimize_coefficients_ga(\n        evaluate_coefficients=evaluator.evaluate,\n        bounds=bounds,\n        optimize_names=names,\n        base_coefficients=base_coefficients,\n        config=GAConfig(\n            population_size=20,\n            generations=100,\n            cxpb=0.5,\n            mutpb=0.3,\n            mutation_eta=10.0,\n            mutation_indpb=0.25,\n            elite_size=2,\n            # Auto worker count keeps script portable between machines.\n            n_jobs=0,\n            # Coarse-to-fine minimizes wasted high-fidelity evaluations.\n            enable_multi_fidelity=True,\n            coarse_stride=3,\n            coarse_until_fraction=0.6,\n            coarse_top_k_full=2,\n            seed=seed,\n        ),\n    )\n\n    return {\n        \"best_values\": {k: result.best_coefficients[k] for k in names},\n        \"fitness_over_time\": result.history,\n        \"actual_error\": [evaluate_partial_coeffs_error([result.best_coefficients[n] for n in names], names)],\n        \"best_cost\": result.best_cost,\n        \"full_coefficients\": result.best_coefficients,\n    }\n</code></pre>"},{"location":"identification/#minos.identification.TSGA_modified.run_tsga_modified","title":"<code>run_tsga_modified()</code>","text":"<p>Run sequential grouped optimization and update running coefficient state.</p> Source code in <code>src\\minos\\identification\\TSGA_modified.py</code> <pre><code>def run_tsga_modified() -&gt; tuple[dict[str, object], dict[str, object]]:\n    \"\"\"Run sequential grouped optimization and update running coefficient state.\"\"\"\n    time_vector = np.linspace(0.0, 50.0, 500)\n    dataset = _build_dataset(time_vector)\n\n    running_coeffs = dict(aero_coeffs)\n    best_coeffs: dict[str, dict[str, float]] = {}\n    metrics: dict[str, dict[str, object]] = {}\n\n    for idx, names in enumerate(GROUPED_NAMES):\n        group_key = \" + \".join(names)\n        result = optimize_group(names, dataset, running_coeffs, seed=100 + idx)\n\n        # Later groups see improvements discovered in earlier groups.\n        for name in names:\n            running_coeffs[name] = float(result[\"best_values\"][name])\n\n        best_coeffs[group_key] = result[\"best_values\"]\n        metrics[group_key] = {\n            \"fitness_over_time\": result[\"fitness_over_time\"],\n            \"time_seconds\": None,\n            \"actual_error\": result[\"actual_error\"],\n            \"best_cost\": result[\"best_cost\"],\n        }\n\n    with OUTPUT_BEST.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(best_coeffs, f, indent=4)\n\n    with OUTPUT_METRICS.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(metrics, f, indent=4)\n\n    return best_coeffs, metrics\n</code></pre>"},{"location":"parallel/","title":"Parallel Execution","text":""},{"location":"parallel/#purpose","title":"Purpose","text":"<p><code>minos.parallel</code> is a domain-agnostic task execution layer for running independent jobs concurrently (for example parameter sweeps and tuning runs).</p> <p>It is intentionally separate from physics/GnC logic:</p> <ul> <li>simulation code defines what to run,</li> <li>parallel code defines how tasks are scheduled/executed.</li> </ul>"},{"location":"parallel/#api","title":"API","text":"<ul> <li><code>TaskSpec</code></li> <li>serializable task definition (<code>task_id</code>, <code>callable_path</code>, args/kwargs).</li> <li><code>TaskOutcome</code></li> <li>stable result envelope (<code>status</code>, <code>result</code>, <code>error</code>, runtime).</li> <li><code>ParallelRunner</code></li> <li>backend selector and execution facade.</li> </ul> <p>Backends:</p> <ul> <li><code>sequential</code></li> <li><code>thread</code></li> <li><code>process</code></li> </ul>"},{"location":"parallel/#backend-selection","title":"Backend Selection","text":"<p>Use:</p> <ul> <li><code>process</code> for CPU-heavy simulation batches.</li> <li><code>thread</code> when process creation is constrained or tasks are mostly I/O/C-extension heavy.</li> <li><code>sequential</code> for debugging and deterministic step-through.</li> </ul>"},{"location":"parallel/#safety-and-assumptions","title":"Safety and Assumptions","text":"<ol> <li>Process backend requires importable top-level callables.</li> <li>Results are returned in input task order, even if completion order differs.</li> <li><code>fail_fast</code> cancels pending work but cannot force-stop already running tasks.</li> </ol>"},{"location":"parallel/#example","title":"Example","text":"<p>Parallel PID step-response sweep:</p> <pre><code>poetry run python examples/parallel_gnc_pid_step_sweep.py --backend process --workers 8\n</code></pre> <p>Thread fallback:</p> <pre><code>poetry run python examples/parallel_gnc_pid_step_sweep.py --backend thread --workers 6\n</code></pre>"},{"location":"physics/","title":"Physics Simulator","text":""},{"location":"physics/#introduction","title":"Introduction","text":"<p>Parafoil dynamics have been modeled at multiple levels of fidelity in the literature, from low-order 3-DoF and 4-DoF approximations to full 6-DoF and higher-order coupled canopy-payload models.</p> <p>Lower-order models are often useful for early guidance and control design because they are computationally light and easier to analyze, but they can miss important coupled rotational and aerodynamic effects needed for accurate closed-loop behavior prediction.</p> <p>Higher-fidelity models (for example 6-DoF rigid-body models, and 8/9-DoF models that include additional canopy-payload coupling) improve physical realism, but increase nonlinearity, parameter count, and computational cost. In practice, parafoil simulation frameworks must balance:</p> <ul> <li>model fidelity,</li> <li>identification effort (many aerodynamic coefficients),</li> <li>numerical robustness,</li> <li>and runtime cost for repeated guidance/control experiments.</li> </ul> <p>This project uses a 6-DoF physics core as the main fidelity level for closed-loop evaluation. The intent is to preserve enough dynamic realism for meaningful GnC comparisons while keeping simulation throughput high enough for strategy iteration and coefficient identification workflows.</p>"},{"location":"physics/#purpose","title":"Purpose","text":"<p>The physics layer is the plant model for the project. It provides a deterministic 6-DoF parafoil simulation that can be driven by:</p> <ul> <li>open-loop input schedules (for baseline analysis and identification), or</li> <li>closed-loop GnC logic (for strategy comparison).</li> </ul> <p>The key design goal is separation of concerns:</p> <ul> <li><code>minos.physics</code> owns vehicle dynamics.</li> <li><code>minos.gnc</code> owns navigation, guidance, and control decisions.</li> <li><code>minos.sim.runners</code> owns simulation loop orchestration.</li> </ul>"},{"location":"physics/#system-layout","title":"System Layout","text":""},{"location":"physics/#1-physics-model-minosphysics","title":"1) Physics model (<code>minos.physics</code>)","text":"<p>The physics package is split by responsibility:</p> <ul> <li><code>types.py</code></li> <li>typed containers for state, derivatives, inputs, coefficients, and parameters.</li> <li>input validation and shape checks.</li> <li><code>frames.py</code></li> <li>coordinate transforms and rotation helpers.</li> <li><code>aero.py</code></li> <li>aerodynamic coefficient and load calculations.</li> <li><code>dynamics.py</code></li> <li>pure derivative evaluation (<code>state_dot</code>) and diagnostics.</li> <li><code>model.py</code></li> <li>stateful plant wrapper (<code>ParafoilModel6DOF</code>) that manages:<ul> <li>current state and inputs,</li> <li>actuator lag for flap deflections,</li> <li>time stepping (RK4),</li> <li>cached diagnostics for logging/analysis.</li> </ul> </li> </ul> <p>This keeps the math testable (pure functions) while still providing a convenient simulation object.</p>"},{"location":"physics/#2-simulation-runners-minossimrunners","title":"2) Simulation runners (<code>minos.sim.runners</code>)","text":"<p><code>minos.sim.runners</code> is the canonical place to run simulations.</p> <ul> <li>Open-loop runners:</li> <li><code>simulate_model</code></li> <li><code>bare_simulate_model</code></li> <li><code>multi_obj_sim</code></li> <li><code>sim_with_noise</code></li> <li><code>sim_state_with_noise</code></li> <li>Closed-loop runner:</li> <li><code>run_simulation_with_gnc</code></li> </ul> <p>All runners use the same underlying physics model and return typed <code>SimulationSnapshot</code> logs for downstream plotting and analysis.</p>"},{"location":"physics/#3-gnc-stack-minosgnc","title":"3) GnC stack (<code>minos.gnc</code>)","text":"<p>The GnC package uses composable interfaces:</p> <ul> <li>Navigator -&gt; estimates quantities (for example wind).</li> <li>Guidance law -&gt; computes high-level commands (for example desired heading).</li> <li>Controller -&gt; maps guidance commands to flap deflections.</li> <li><code>GncStack</code> -&gt; orchestrates the above and outputs <code>Inputs</code> for the plant.</li> </ul> <p>The physics model does not implement control policy; it only consumes <code>Inputs</code>.</p>"},{"location":"physics/#end-to-end-data-flow","title":"End-to-End Data Flow","text":""},{"location":"physics/#open-loop-flow","title":"Open-loop flow","text":"<ol> <li>Provide time vector + flap/wind input series.</li> <li>Runner applies those inputs each step.</li> <li>Physics model advances state.</li> <li>Snapshots are logged.</li> </ol>"},{"location":"physics/#closed-loop-gnc-flow","title":"Closed-loop GnC flow","text":"<ol> <li>Runner builds an <code>Observation</code> from the current simulator state/diagnostics.</li> <li><code>GncStack.update(observation, dt)</code> runs:</li> <li>navigation,</li> <li>guidance,</li> <li>control.</li> <li>Stack returns plant <code>Inputs</code> (<code>flap_left</code>, <code>flap_right</code>, wind).</li> <li>Runner applies inputs to <code>ParafoilModel6DOF</code> and steps physics.</li> <li>Runner logs <code>SimulationSnapshot</code> with dynamics and command context.</li> </ol> <p>This architecture enables fair strategy comparison: swap GnC components while keeping the same physics plant and runner loop.</p>"},{"location":"physics/#what-to-change-for-new-experiments","title":"What To Change For New Experiments","text":"<ul> <li>Change physics assumptions:</li> <li>edit <code>minos.physics</code> (coefficients, forces/moments, parameters).</li> <li>Change guidance/control strategy:</li> <li>add or swap components in <code>minos.gnc</code>.</li> <li>Change how scenarios are executed or logged:</li> <li>edit <code>minos.sim.runners</code>.</li> </ul> <p>Keep those concerns separate to avoid coupling strategy logic into plant dynamics.</p>"},{"location":"physics/#examples","title":"Examples","text":"<ul> <li>Open-loop physics example:</li> <li><code>examples/physics_model_3d_example.py</code></li> <li>Closed-loop modular GnC example:</li> <li><code>examples/gnc_3d_example.py</code></li> </ul> <p>These are the recommended entry points for understanding and extending the current architecture.</p>"},{"location":"simulation/","title":"Simulation Runners","text":""},{"location":"simulation/#canonical-api","title":"Canonical API","text":"<p><code>minos.sim.runners</code> is the single simulation entrypoint module.</p>"},{"location":"simulation/#open-loop-runners","title":"Open-loop runners","text":"<ul> <li><code>simulate_model</code></li> <li>full typed snapshots plus state history.</li> <li><code>bare_simulate_model</code></li> <li>position trajectory only.</li> <li><code>multi_obj_sim</code></li> <li>state trajectory for optimization workflows.</li> <li><code>sim_with_noise</code></li> <li>noisy position measurements.</li> <li><code>sim_state_with_noise</code></li> <li>noisy state trajectories.</li> </ul> <p>Use open-loop runners when flap/wind inputs are pre-defined.</p>"},{"location":"simulation/#closed-loop-runner","title":"Closed-loop runner","text":"<ul> <li><code>run_simulation_with_gnc</code></li> <li>integrates <code>ParafoilModel6DOF</code> with <code>GncStack</code> in a feedback loop.</li> </ul> <p>Use this runner for guidance/control strategy testing.</p>"},{"location":"simulation/#inputs-and-outputs","title":"Inputs and outputs","text":"<p>All runners are built around:</p> <ul> <li>physics inputs (<code>Inputs</code>) and state (<code>State</code>) for plant execution,</li> <li><code>SimulationSnapshot</code> logs for analysis and plotting.</li> </ul> <p><code>SimulationSnapshot</code> is the common data product across open-loop and closed-loop runs.</p> <p>For closed-loop GnC runs, snapshots may additionally include:</p> <ul> <li>guidance phase label,</li> <li>flare magnitude command,</li> <li>navigation wind estimate,</li> <li>raw and clipped control commands.</li> </ul>"},{"location":"simulation/#design-guidance","title":"Design guidance","text":"<p>When adding new simulation behavior:</p> <ol> <li>Extend <code>minos.sim.runners</code> instead of embedding loops into physics or GnC modules.</li> <li>Keep runner responsibilities orchestration-only.</li> <li>Keep strategy logic inside <code>minos.gnc</code> and dynamics inside <code>minos.physics</code>.</li> </ol>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python <code>3.12+</code></li> <li>Poetry</li> </ul>"},{"location":"usage/#installation","title":"Installation","text":"<pre><code>git clone &lt;repo-url&gt;\ncd Level_4_project\npoetry install\n</code></pre>"},{"location":"usage/#recommended-execution-pattern","title":"Recommended execution pattern","text":"<p>Use Poetry without manually activating environments:</p> <pre><code>poetry run python &lt;script.py&gt;\n</code></pre>"},{"location":"usage/#first-runs","title":"First runs","text":"<p>Open-loop physics + plots + 3D animation:</p> <pre><code>poetry run python examples/physics_model_3d_example.py\n</code></pre> <p>Closed-loop modular GnC example:</p> <pre><code>poetry run python examples/gnc_3d_example.py\n</code></pre> <p>Closed-loop T-approach v2 example:</p> <pre><code>poetry run python examples/gnc_t_approach_2_example.py --no-show\n</code></pre> <p>Headless GnC smoke run:</p> <pre><code>poetry run python examples/gnc_3d_example.py --no-show\n</code></pre> <p>Parallel PID heading-step sweep (process backend):</p> <pre><code>poetry run python examples/parallel_gnc_pid_step_sweep.py --backend process --workers 8 --no-show\n</code></pre> <p>If process pools are restricted in your environment, use thread backend:</p> <pre><code>poetry run python examples/parallel_gnc_pid_step_sweep.py --backend thread --workers 6 --no-show\n</code></pre>"},{"location":"usage/#canonical-simulation-apis","title":"Canonical simulation APIs","text":"<p>Use <code>minos.sim.runners</code> as the main integration surface:</p> <ul> <li><code>simulate_model</code> for open-loop schedule-driven runs.</li> <li><code>run_simulation_with_gnc</code> for closed-loop GnC runs.</li> <li><code>bare_simulate_model</code>, <code>multi_obj_sim</code>, and noise variants for identification workflows.</li> </ul>"},{"location":"usage/#typical-workflow","title":"Typical workflow","text":"<ol> <li>Build scenario and initial state in physics terms.</li> <li>Choose open-loop or closed-loop runner.</li> <li>Run simulation to produce <code>SimulationSnapshot</code> data.</li> <li>Plot/analyze with utilities or custom scripts.</li> </ol>"}]}