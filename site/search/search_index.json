{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Minos","text":"<p>Minos is a Python project for [insert short description].</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Feature 1</li> <li>Feature 2</li> <li>Feature 3</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>```bash pip install -e .</p>"},{"location":"api/","title":"Minos API Reference","text":""},{"location":"guidance/","title":"Physics Simulator","text":""},{"location":"guidance/#minos.guidance.guidance_v2.compute_required_heading","title":"<code>compute_required_heading(wind_vector, airspeed, target_vector)</code>","text":"<p>Calculate the required heading angle to follow the desired vector in wind. Uses wind triangle, taking norms and solving quadratic for ground speed along  desired vector.  Args:     wind_vector (list): (w_x, w_y), wind vector in m/s.     airspeed (float): Airspeed of the parafoil  in m/s.     target_vector (list): (d_x, d_y), vector pointing to the desired target.</p> <p>Returns:</p> Type Description <code>    float: Required heading angle in radians.</code> <p>np.ndarray: Air velocity vector (v_a_x, v_a_y).</p> Source code in <code>src\\minos\\guidance\\guidance_v2.py</code> <pre><code>def compute_required_heading(wind_vector, airspeed, target_vector):\n    \"\"\"\n    Calculate the required heading angle to follow the desired vector in wind.\n    Uses wind triangle, taking norms and solving quadratic for ground speed along \n    desired vector. \n    Args:\n        wind_vector (list): (w_x, w_y), wind vector in m/s.\n        airspeed (float): Airspeed of the parafoil  in m/s.\n        target_vector (list): (d_x, d_y), vector pointing to the desired target.\n\n    Returns\n    -------\n        float: Required heading angle in radians.\n        np.ndarray: Air velocity vector (v_a_x, v_a_y).\n    \"\"\"\n    # format and normalise\n    w = np.array(wind_vector)\n    d = np.array(target_vector)\n    d_hat = d / np.linalg.norm(d)\n\n    # Solve for Vg using quadratic equation\n    a = 1\n    b = -2 * np.dot(d_hat, w)\n    c = np.dot(w, w) - airspeed**2\n\n    discriminant = b**2 - 4 * a * c\n    if discriminant &lt; 0:\n        raise ValueError(\"No solution: desired vector cannot be achieved with given airspeed and wind.\")\n\n    Vg = (-b + np.sqrt(discriminant)) / (2 * a)\n\n    # Compute air velocity vector\n    v_g = Vg * d_hat\n    v_a = v_g - w\n\n    # Compute heading angle\n    heading = np.arctan2(v_a[1], v_a[0])\n\n    return heading, v_a\n</code></pre>"},{"location":"guidance/#minos.guidance.guidance_v2.guidance_update","title":"<code>guidance_update(params, state)</code>","text":"<p>Update the state of the system based on the current state and time. This function is called at each time step of the simulation.</p> Source code in <code>src\\minos\\guidance\\guidance_v2.py</code> <pre><code>def guidance_update(params, state):\n    \"\"\"\n    Update the state of the system based on the current state and time.\n    This function is called at each time step of the simulation.\n    \"\"\"\n    flare_magnitude = 0\n    # Get the current position from the simulator\n    position, current_velocity, current_height, current_heading = update_kinematics(params, state)\n\n    #params[\"wind_v_list\"].append(current_velocity)\n    #wind_estimate = least_squares_wind_calc(params[\"wind_v_list\"])\n\n    # check that we will make it to the IPI\n    if params[\"mode\"] != \"Final Approach\":\n        # easy\n        vertical_time_to_IPI = (current_height - params[\"IPI\"][2]) / params[\"sink_velocity\"]\n        # first we need to get the effective vel (including wind)\n        vector_to_IPI = params[\"IPI\"][:2] - position[:2]\n        direction_to_IPI = vector_to_IPI / np.linalg.norm(vector_to_IPI)\n        effective_vel = params[\"horizontal_velocity\"] * direction_to_IPI + params[\"wind_magnitude\"] * params[\"wind_unit_vector\"]\n        # get the effective vel componenet along the direction to the IPI\n        groundspeed_along_path = np.dot(effective_vel, direction_to_IPI)\n        if groundspeed_along_path &lt;= 0:\n            # we are never going to make it\n            horizontal_time_to_IPI = vertical_time_to_IPI + 1\n        else:\n            horizontal_time_to_IPI =  np.linalg.norm(vector_to_IPI) / groundspeed_along_path\n\n        if vertical_time_to_IPI &lt; horizontal_time_to_IPI:\n            print(\"heading to IPI prematurely\")\n            vector_to_IPI = params[\"IPI\"][:2] - position\n            # perpendicular vector to the wind direction\n            params[\"desired_heading\"] = smooth_heading_to_line_with_wind(position, params[\"IPI\"][:2], vector_to_IPI, \n                                                                    10, params[\"wind_unit_vector\"] *params[\"wind_magnitude\"], params[\"horizontal_velocity\"])\n            return params[\"desired_heading\"], flare_magnitude\n\n    # get estimate of time until FTP height reached\n    time_to_FTP = (current_height - params[\"final_approach_height\"]) / params[\"sink_velocity\"]\n    spiral_centre_current = params[\"FTP_centre\"] - time_to_FTP * params[\"wind_unit_vector\"] * params[\"wind_magnitude\"]\n\n    if time_to_FTP  &lt; 0:\n        # we have hit FTP\n        params[\"mode\"] = \"Final Approach\"\n\n    if params[\"mode\"] == \"Final Approach\":\n        print(\"Final Approach\")\n        # line up with the wind...\n        params[\"desired_heading\"] = smooth_heading_to_line_with_wind(position, params[\"FTP_centre\"], - params[\"wind_unit_vector\"], \n                                                                10, params[\"wind_unit_vector\"] *params[\"wind_magnitude\"], params[\"horizontal_velocity\"])\n        # flare at 10m\n        if(current_height &lt; params[\"flare_height\"]):\n            flare_magnitude = 1\n\n    elif params[\"mode\"] == \"initialising\":\n\n        params[\"RLS\"].update(current_velocity[0],current_velocity[1])\n        wind_estimate = params[\"RLS\"].get_wind_estimate()\n        update_wind(params, wind_estimate)\n\n       # params[\"wind_v_list\"].append(current_velocity)\n       # wind_estimate = least_squares_wind_calc(params[\"wind_v_list\"])\n       # update_wind(params,wind_estimate)   \n        if params[\"initialised\"] == False:\n            # set the start heading for the wind estimation\n            print(\"SETTING STARTING HEADING\")\n            params[\"start_heading\"] = current_heading\n            params[\"initialised\"] = True\n        # Generate critical points for the T-approach algorithm\n        # we need raw state to check if the thing has rotated over 360 degrees\n        if state[2][2] - params[\"start_heading\"] &gt; np.deg2rad(360):\n            print(\"Generating critical points\")\n            # get the wind estimate\n            #wind_estimate = least_squares_wind_calc(params[\"wind_v_list\"])\n            #update_wind(params,wind_estimate)\n            # update the FTP centre\n            params[\"mode\"] = \"homing\"\n            position, current_velocity, current_height, current_heading = update_kinematics(params, state)\n        else:\n            print(\"Initialising\")\n            # params[\"wind_v_list\"].append(current_velocity)\n            # keep going in a circle\n            angular_vel = params[\"horizontal_velocity\"] / params[\"spirialing_radius\"]\n            delta_heading = angular_vel * params[\"update_rate\"]\n            # go clockwise, add onto desired heading\n            params[\"desired_heading\"] += delta_heading\n\n\n    # initialising mode could've been set to homing mode in the last update, better check\n    if params[\"mode\"] == \"homing\":\n        print(\"Homing\")\n\n        params[\"RLS\"].update(current_velocity[0],current_velocity[1])\n        wind_estimate = params[\"RLS\"].get_wind_estimate()\n        update_wind(params, wind_estimate)\n\n        # work out the distance and heading to get to this point\n        vector_to_centre = spiral_centre_current - position\n        # perpendicular vector to the wind direction\n        perp_vector = np.array([vector_to_centre[1], -vector_to_centre[0]])\n        distance_to_tangent = np.linalg.norm(vector_to_centre)\n        # add perp vector so we line up with the circle\n        vector_to_tangent = spiral_centre_current + perp_vector / np.linalg.norm(perp_vector) * params[\"spirialing_radius\"] * 0.9 - position\n        # calculate the desired heading\n        params[\"desired_heading\"],_ = compute_required_heading(params[\"wind_unit_vector\"] * params[\"wind_magnitude\"], params[\"horizontal_velocity\"], vector_to_tangent)\n        # calculate the heading\n        params[\"desired_heading\"] = wrap_angle(params[\"desired_heading\"])\n\n        \"\"\"        # Plot setup\n        plt.figure(figsize=(8, 8))\n        plt.axis('equal')\n        plt.grid(True)\n        plt.title(\"Parafoil Homing Guidance\")\n\n        # Plot parafoil position\n        plt.plot(position[0], position[1], 'bo', label='Parafoil Position')\n\n        # Plot current heading vector\n        current_heading_vector = np.array([\n            np.cos(current_heading),\n            np.sin(current_heading)\n        ]) * 10  # scale for visibility\n        plt.arrow(position[0], position[1],\n                current_heading_vector[0], current_heading_vector[1],\n                head_width=1, color='blue', label='Current Heading')\n\n        # Plot desired heading vector\n        desired_heading_vector = np.array([\n            np.cos(params[\"desired_heading\"]),\n            np.sin(params[\"desired_heading\"])\n        ]) * 10  # scale for visibility\n        plt.arrow(position[0], position[1],\n                desired_heading_vector[0], desired_heading_vector[1],\n                head_width=1, color='green', label='Desired Heading')\n\n        # plot wind\n        wind_vector = params[\"wind_unit_vector\"] * 10\n        plt.arrow(position[0], position[1],\n                wind_vector[0], wind_vector[1],\n                head_width=1, color='yellow', label='wind vector')\n        # plot actual velocity\n        plt.arrow(position[0], position[0], \n                state[1][0], state[1][1],\n                head_width=1, color='orange', label='actual velocity vector')\n        # Plot spiral centre\n        plt.plot(spiral_centre_current[0], spiral_centre_current[1], 'rx', label='Spiral Centre')\n\n        # Plot IPI point (assumed FTP_centre)\n        plt.plot(ipi_point[0], ipi_point[1], 'ms', label='IPI (FTP Centre)')\n\n        # Add legend and labels\n        plt.xlabel(\"X Position\")\n        plt.ylabel(\"Y Position\")\n        plt.legend()\n        # plt.show()\"\"\"\n\n        # Check if we need to start turning into the final approach\n        if distance_to_tangent &lt; 1.2 * params[\"spirialing_radius\"]:\n            params[\"mode\"] = \"energy_management\"\n\n    # homing mode could've been set to energy management mode in the last update, better check\n    if params[\"mode\"] == \"energy_management\":\n\n            print(\"Energy Management\")\n            dist_to_CTP = np.linalg.norm(np.subtract(position, spiral_centre_current))\n            if dist_to_CTP &gt; 5 * params[\"spirialing_radius\"]:\n                params[\"mode\"] = \"homing\"\n            #params[\"wind_v_list\"].append(current_velocity)\n           # wind_estimate = least_squares_wind_calc(params[\"wind_v_list\"])\n            #update_wind(params,wind_estimate)\n            # keep going in a circle\n            angular_vel = params[\"horizontal_velocity\"] / params[\"spirialing_radius\"]\n            delta_heading = angular_vel * params[\"update_rate\"]\n            # go clockwise, add onto desired heading\n            params[\"desired_heading\"] += delta_heading\n    params[\"desired_heading\"] = wrap_angle(params[\"desired_heading\"])\n    return params[\"desired_heading\"], flare_magnitude\n</code></pre>"},{"location":"guidance/#minos.guidance.guidance_v2.simple_control","title":"<code>simple_control(current_heading, desired_heading, heading_rate)</code>","text":"<p>Takes both headings in radians, returns flap deflections</p> Source code in <code>src\\minos\\guidance\\guidance_v2.py</code> <pre><code>def simple_control(current_heading, desired_heading, heading_rate):\n    \"\"\"\n    Takes both headings in radians, returns flap deflections\n    \"\"\"\n    # convert and calcuate requred headings\n    current_heading = wrap_angle_pi_to_pi(current_heading)\n    desired_heading = wrap_angle_pi_to_pi(desired_heading)\n    heading_error = wrap_angle_pi_to_pi(desired_heading - current_heading)\n    print(f\"current heading: {np.rad2deg(current_heading)}, desired heading: {np.rad2deg(desired_heading)}, heading error: {np.rad2deg(heading_error)}\")\n    # double check that heading error is correct\n    # convert to degrees for easibility\n    heading_error = np.rad2deg(heading_error)\n    deflections = [0,0]\n    magnitude = 0.5\n    if heading_error &lt; 0:\n        deflections = [1,0]\n    else:\n        deflections = [0,1]\n    if abs(heading_error) &lt; 1:\n        magnitude = 0\n    elif abs(heading_error) &lt; 3:\n        magnitude = 0.1\n    elif abs(heading_error) &lt; 5:\n        magnitude = 0.2\n    elif abs(heading_error) &lt; 10:\n        magnitude = 0.3\n    elif abs(heading_error) &lt; 30:\n        magnitude = 0.4\n    return [magnitude * deflections[0], magnitude * deflections[1]]\n</code></pre>"},{"location":"guidance/#minos.guidance.guidance_v2.smooth_heading_to_line_with_wind","title":"<code>smooth_heading_to_line_with_wind(position, line_point, line_direction, lookahead_distance, wind_vector, airspeed)</code>","text":"<p>Compute the heading required to move toward the lookahead point, considering wind.</p> Source code in <code>src\\minos\\guidance\\guidance_v2.py</code> <pre><code>def smooth_heading_to_line_with_wind(position, line_point, \n                                     line_direction, lookahead_distance, wind_vector, airspeed):\n    \"\"\"\n    Compute the heading required to move toward the lookahead point, considering wind.\n    \"\"\"\n    p = np.array(position)\n    a = np.array(line_point)\n    d = np.array(line_direction)\n    d = d / np.linalg.norm(d)\n\n    # Project position onto the line to find the closest point\n    ap = p - a\n    t = np.dot(ap, d)\n    closest_point = a + t * d\n\n    # Lookahead point on the line\n    lookahead_point = closest_point + d * lookahead_distance\n\n    # Desired ground track vector\n    desired_track = lookahead_point - p\n    desired_track /= np.linalg.norm(desired_track)\n\n    # Solve for air vector that, when combined with wind, gives the desired track\n    air_vector = desired_track * airspeed - wind_vector\n\n    # Compute heading from air vector\n    required_heading = np.arctan2(air_vector[1], air_vector[0])\n    return required_heading\n</code></pre>"},{"location":"guidance/#minos.guidance.guidance_v2.update_kinematics","title":"<code>update_kinematics(params, state)</code>","text":"<p>Update the kinematics of the system based on the current state.</p> Source code in <code>src\\minos\\guidance\\guidance_v2.py</code> <pre><code>def update_kinematics(params, state):\n    \"\"\"\n    Update the kinematics of the system based on the current state.\n    \"\"\"\n    position = state[0][:2]\n    current_height = state[0][2]\n    current_velocity = state[1][:2]\n    current_heading = wrap_angle(state[2][2])\n    if params[\"mode\"] != \"initialising\":\n        time = params[\"final_approach_height\"] / params[\"sink_velocity\"]\n        params[\"FTP_centre\"] = params[\"IPI\"][:2] + (params[\"horizontal_velocity\"] - params[\"wind_magnitude\"])  * time * params[\"wind_unit_vector\"]\n    return position, current_velocity, current_height, current_heading\n</code></pre>"},{"location":"guidance/#minos.guidance.guidance_v2.update_wind","title":"<code>update_wind(params, wind_vector)</code>","text":"<p>Update the wind vector based on the current state. This function is called at each time step of the simulation.</p> Source code in <code>src\\minos\\guidance\\guidance_v2.py</code> <pre><code>def update_wind(params, wind_vector):\n    \"\"\"\n    Update the wind vector based on the current state.\n    This function is called at each time step of the simulation.\n    \"\"\"\n    # Update the wind vector based on the current state\n    wind_2d = np.array([wind_vector[0], wind_vector[1]])\n    # Update the wind vector based on the current state\n    params[\"wind_magnitude\"] = np.linalg.norm(wind_2d)\n    params[\"wind_unit_vector\"] = wind_2d / params[\"wind_magnitude\"]\n    params[\"wind_heading\"] = np.arctan2(wind_2d[1], wind_2d[0])\n    if params[\"wind_magnitude\"] &lt; 0.3:\n        params[\"wind_magnitude\"] = 0.0\n        params[\"wind_unit_vector\"] = np.array([1, 0])\n        params[\"wind_heading\"] = 0.0\n</code></pre>"},{"location":"guidance/#minos.guidance.guidance_v2.wrap_angle","title":"<code>wrap_angle(angle)</code>","text":"<p>Returns angle within the bounds of 0 and 2 PI</p> Source code in <code>src\\minos\\guidance\\guidance_v2.py</code> <pre><code>def wrap_angle(angle):\n    \"\"\"\n    Returns angle within the bounds of 0 and 2 PI\n    \"\"\"\n    return (angle + 2 * np.pi) % (2 * np.pi)\n</code></pre>"},{"location":"guidance/#minos.guidance.guidance_v2.wrap_angle_pi_to_pi","title":"<code>wrap_angle_pi_to_pi(angle)</code>","text":"<p>Returns angle within the bounds of -PI and PI</p> Source code in <code>src\\minos\\guidance\\guidance_v2.py</code> <pre><code>def wrap_angle_pi_to_pi(angle):\n    \"\"\"\n    Returns angle within the bounds of -PI and PI\n    \"\"\"\n    return (wrap_angle(angle) + np.pi) % (2 * np.pi) - np.pi\n</code></pre>"},{"location":"identification/","title":"Physics Model identification","text":""},{"location":"physics/","title":"Physics Simulator","text":""},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof","title":"<code>ParafoilSimulation_6Dof</code>","text":"<p>A class to simulate the dynamics of a parafoil system in 6 degrees of freedom.</p> <p>The simulation includes the effects of aerodynamic forces, moments, and gravity. doesnt include the effects of the payload, apparent mass</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>class ParafoilSimulation_6Dof:\n    \"\"\"\n    A class to simulate the dynamics of a parafoil system in 6 degrees of freedom.\n\n    The simulation includes the effects of aerodynamic forces, moments, and gravity.\n    doesnt include the effects of the payload, apparent mass\n    \"\"\"\n\n    def __init__(self,params,state, inputs):\n        \"\"\"\n        Initialize the simulation.\n\n        Parameters\n        ----------\n        params : dict\n            System parameters such as mass, geometry, and aerodynamic coefficients.\n\n        state : list\n            Initial state vector [position, velocity_body, eulers, angular_velocity].\n\n        inputs : list\n            Simulation inputs [flap deflection angles, wind vector].\n        \"\"\"\n        self.set_system_params(params)\n        self.set_inputs(inputs)\n        self.set_state(state)\n        self.error = False\n        # calculate the derivatives\n        self.calculate_derivatives()\n\n    def set_inputs(self, inputs):\n        \"\"\"\n        Set the inputs for the simulation.\n\n        Parameters\n        ----------\n        inputs : list\n            A list containing:\n            - input[0]: Tuple[float, float], flap deflection angles (left, right).\n            - input[1]: np.ndarray, wind vector in the inertial frame.\n        \"\"\"\n        self.set_actual_flaps(inputs[0])\n        self.w = inputs[1] # wind vector in inertial frame\n\n    def set_actual_flaps(self, input):\n        \"\"\"\n        Set both actual and desired flap deflections.\n\n        Parameters\n        ----------\n        input : tuple of float\n            Left and right flap deflections (radians).\n        \"\"\"\n\n        self.flap_l,self.flap_r = input\n        self.flap_l_desired,self.flap_r_desired = input\n        self.update_flaps(1) # doesnt matter, they be the same\n\n    def set_desired_flaps(self, input):\n        \"\"\"\n        Set desired flap deflections.\n\n        Parameters\n        ----------\n        input : tuple of float\n            Desired left and right flap deflections (radians).\n        \"\"\"\n\n        self.flap_l_desired,self.flap_r_desired = input\n\n    def update_flaps(self,dt):\n        \"\"\"\n        Update flap positions based on the desired values and rate limits.\n\n        Parameters\n        ----------\n        dt : float\n            Time step (seconds).\n        \"\"\"\n        max_rate = dt/self.flap_time_constant\n        self.flap_l += np.clip(self.flap_l_desired - self.flap_l, -max_rate, max_rate) \n        self.flap_r += np.clip(self.flap_r_desired - self.flap_r, -max_rate, max_rate) \n        # calculate the flap deflection angles\n        self.delta_a = self.flap_r - self.flap_l  # asymmetric flap deflection\n        self.delta_s = 0.5*(self.flap_l + self.flap_r) # symmetric flap deflection\n\n    def set_state(self, state):\n        \"\"\"\n        Set the state of the simulation. Also updates the kinematic transformations.\n\n        Parameters\n        ----------\n        state : list\n            State vector [position, velocity_body, eulers, angular_velocity].\n        \"\"\"\n        self.p = state[0] # position in inertial frame\n        self.vb = self.safe_clamp_vector(state[1]) # velocity in body fixed frame\n        self.eulers = state[2] # euler angles IN RADIANS of body in inertal frame\n        self.angular_vel = self.safe_clamp_vector(state[3]) # angular velocities in body fixed frame\n        # update the transformations:\n        self.update_kinematic_transforations()\n        self.update_wind_transformations()\n\n    def set_coefficients(self, coefficients=None):\n        \"\"\"\n        Set the aerodynamic coefficients for the simulation.\n        Accepts either a list (in predefined order) or a dictionary (by name).\n\n        Parameters\n        ----------\n        coefficients : list or dict, optional\n            Aerodynamic coefficients. If None, defaults are used.\n        \"\"\"\n        if coefficients is None:\n            return\n\n        # Handle dictionary input\n        if isinstance(coefficients, dict):\n            for name in [\n                \"CDo\", \"CDa\", \"CD_sym\", \"CLo\", \"CLa\", \"CL_sym\",\n                \"CYB\", \"ClB\", \"Clp\", \"Clr\", \"Cl_asym\", \"Cmo\",\n                \"Cma\", \"Cmq\", \"CnB\", \"Cn_p\", \"Cn_r\", \"Cn_asym\"\n            ]:\n                if name in coefficients:\n                    setattr(self, name, coefficients[name])\n            return\n\n        # Handle list input\n        if isinstance(coefficients, list) or isinstance(coefficients, tuple):\n            if len(coefficients) &lt; 18:\n                raise ValueError(\"Coefficient list must have at least 18 values.\")\n            (\n                self.CDo, self.CDa, self.CD_sym,\n                self.CLo, self.CLa, self.CL_sym,\n                self.CYB, self.ClB, self.Clp, self.Clr, self.Cl_asym,\n                self.Cmo, self.Cma, self.Cmq,\n                self.CnB, self.Cn_p, self.Cn_r, self.Cn_asym\n            ) = coefficients\n            return\n\n    def check_set_param(self, dict, param_name):\n        \"\"\"\n        Check if the parameter is set in the dictionary and if its type matches the expected type.\n        If so, sets the instance variable self.&lt;attr_name&gt; to the value from the dictionary.\n\n        Parameters\n        ----------\n        dict : dict\n            Dictionary containing parameters of the simulation.\n        param_name : str\n            Name of the parameter to check and set.\n\n        Returns\n        -------\n        bool\n            True if the parameter was found and set, False otherwise.\n        \"\"\"\n        param = dict.get(param_name)\n        if param is None:\n            return False\n        elif not hasattr(self, param_name):\n            raise AttributeError(f\"Attribute '{param_name}' does not exist on the instance.\")\n        elif type(getattr(self, param_name)) != type(param):\n            raise TypeError(f\"Parameter '{param_name}' should be of type {type(getattr(self, param_name))}. Got {type(param)} instead.\")\n\n        setattr(self, param_name, param)\n\n        # print(f\"Set {param_name} to {param}\")\n        return True\n\n    def set_system_params(self,system_params):\n        \"\"\"\n        Set the system parameters for the simulation. Default values follow Snowflake PAD model.\n\n        see: Yakimenko, Oleg A.. (2015). &lt;i&gt;Precision Aerial Delivery Systems - Modeling, Dynamics, and Control\n\n        Parameters\n        ----------\n        params : dict\n            Keys must include:\n            - m : float, mass [kg]\n            - b : float, span [m]\n            - S : float, area [m^2]\n            - c : float, chord [m]\n            - x_cg : float, CG x-location [m]\n            - z_cg : float, CG z-location [m]\n            - Ixx, Iyy, Izz, Ixz : float, inertia terms\n            - flap_time_constant : float, flap actuator time constant\n            - C_* : float, aerodynamic coefficients\n        \"\"\"\n        # ------------------- simulation params --------------\n        self.dt = 0.1\n        self.check_set_param(system_params, \"dt\")\n\n        # -------------------- parafoil params\n\n        # aerodynamic parameters, default values follow Snowflake PAD model.\n        self.S = 1.0\n        self.check_set_param(system_params, \"S\") # surface area of parafoil\n        self.c = 0.75\n        self.check_set_param(system_params, \"c\") # mean chord length\n        #self.AR = 0.0\n        #self.check_set_param(system_params, self.AR, \"AR\") # aspect ratio\n        self.t = 0.075\n        self.check_set_param(system_params, \"t\") # thickness of the parafoil\n        self.b = 1.35\n        self.check_set_param(system_params, \"b\") # wingspan of the parafoil\n        self.rigging_angle = np.radians(-12.0)\n        self.check_set_param(system_params, \"rigging_angle\")\n\n        # system parameters\n        self.m = 2.4 # mass of the system\n        self.check_set_param(system_params, \"m\") # mass of the system\n        self.Rp = np.array([0.0,0,-1.11]) # distance between parafoil and the center of mass for the system\n\n\n        self.check_set_param(system_params, \"Rp\")\n\n        self.I = np.array([[0.42,0,0.03],[0,0.4,0],[0.03,0,0.053]]) # moment of inertia of the system\n        # if we have to do our own calculations, we need more info\n        self.check_set_param(system_params, \"I\") # moment of inertia of the system\n\n\n        self.initial_pos = [0,0,0] # initial position of the system in inertial frame\n        self.check_set_param(system_params, \"initial_pos\")\n\n        self.flap_time_constant = 1 # number of seconds to go from 0 flap to max flap\n        self.check_set_param(system_params, \"flap_time_constant\")\n\n        \"\"\"\"\n        self.parafoil_mass = 0.0\n        self.check_set_param(system_params,self.parafoil_mass, \"parafoil_mass\") # mass of parafoil\n        self.payload_mass = 0.0\n        self.check_set_param(system_params,self.payload_mass, \"payload_mass\") # mass of payload\n        self.Rlc = 0.0\n        self.check_set_param(system_params,self.Rlc, \"Rlc\") # distance between payload CoM and connection point to parafoil\n        self.Rpc = 0.0\n        self.check_set_param(system_params,self.Rpc, \"Rpc\") # distance between parafoil CoM and connection point to parafoil\n\n        self.m = self.parafoil_mass + self.payload_mass # mass of entire system\n\n        \"\"\"\n\n        # ________________ aerodynamic parameters ____________________\n        # for drag\n        self.CD = 0\n        self.CDo = 0.25\n        self.check_set_param(system_params, \"CDo\")\n        self.CDa = 0.12\n        self.check_set_param(system_params, \"CDa\") # drag coefficient\n        self.CD_sym = 0.2\n        self.check_set_param(system_params, \"CD_sym\")\n\n        # for lift\n        self.CL = 0\n        self.CLo = 0.091\n        self.check_set_param(system_params, \"CL\") # lift coefficient\n        self.CLa = 0.90\n        self.check_set_param(system_params, \"CLa\") # lift coefficient changing due to angle of incidance\n        self.CL_sym = 0.2\n        self.check_set_param(system_params, \"CL_sym\") # lift coefficient changing due to angle of incidance\n\n        # for side force\n        self.CYB = -0.23\n        self.check_set_param(system_params, \"CYB\") # side force coefficient\n\n        # for rolling\n        self.Cl = 0\n        self.ClB = -0.036 # coefficient due to sideslip angle\n        self.check_set_param(system_params, \"clB\")\n        self.Clp = -0.84\n        self.check_set_param(system_params,\"Clp\")\n        self.Clr = -0.082\n        self.check_set_param(system_params,\"Clr\")\n        self.Cl_asym = -0.0035 # coefficient due to asymmetric flap deflection\n        self.check_set_param(system_params, \"Cl_asym\")\n\n        # for pitching\n        self.Cm = 0\n        self.Cmo = 0.35 # coefficient at zero lift\n        self.check_set_param(system_params, \"Cmo\")\n        self.Cma = -0.72 # coefficient due to angle of incidance\n        self.check_set_param(system_params, \"Cma\")\n        self.Cmq = -1.49\n        self.check_set_param(system_params, \"Cmq\") # coefficient due to pitch rate\n\n        # for yawing\n        self.Cn = 0\n        self.CnB = -0.0015 # coefficient due to sideslip angle\n        self.check_set_param(system_params, \"CnB\")\n        self.Cn_p = -0.082 # coefficient due to roll rate\n        self.check_set_param(system_params, \"Cn_p\")\n        self.Cn_r = -0.27\n        self.check_set_param(system_params, \"Cn_r\") # coefficient due to yaw rate\n        self.Cn_asym = 0.0115\n        self.check_set_param(system_params, \"Cn_asym\") # coefficient due to asymmetric flap deflection           \n\n    def get_state(self):\n        \"\"\"\n        Get the current state vector.\n\n        Returns\n        -------\n        list\n            [position, velocity_body, eulers, angular_velocity].\n        \"\"\"\n        return [self.p, self.vb, self.eulers, self.angular_vel]\n\n    def get_inertial_position(self):\n        \"\"\"\n        Get the position in the inertial frame.\n        Returns\n        -------\n        np.ndarray\n            Position in the inertial frame.\n        \"\"\"\n        ned_to_world = np.array([1, 1, -1])  # Flip Z-axis\n        inertial_pos = self.initial_pos + ned_to_world * self.p  # Element-wise multiplication\n        return inertial_pos\n\n    def get_inertial_state(self):\n        \"\"\"\n        Get the current state vector in the inertial frame.\n        Returns\n        -------\n        list\n            [position_inertial, velocity_inertial, eulers, euler_rates].\n        \"\"\"\n\n        return[self.get_inertial_position(), self.body_to_inertial(self.vb), self.eulers, self.get_euler_rates()]\n\n    def get_CDM(self, euler_angles = None):\n        \"\"\"\n        Get the rotation matrix from body to inertial frame\n        Parameters\n        ----------\n        euler_angles : tuple or list, optional\n            Euler angles (phi, theta, psi) in radians. If None, uses current state.\n\n        Returns\n        -------\n        np.ndarray\n            3x3 rotation matrix.\"\"\"\n\n        if euler_angles is None:\n            phi, theta, psi = self.eulers\n        else:\n            phi, theta, psi = euler_angles\n        return np.array([\n        [np.cos(theta) * np.cos(psi), np.sin(phi) * np.sin(theta) * np.cos(psi) - np.cos(phi) * np.sin(psi), np.cos(phi) * np.sin(theta) * np.cos(psi) + np.sin(phi) * np.sin(psi)],\n        [np.cos(theta) * np.sin(psi), np.sin(phi) * np.sin(theta) * np.sin(psi) + np.cos(phi) * np.cos(psi), np.cos(phi) * np.sin(theta) * np.sin(psi) - np.sin(phi) * np.cos(psi)],\n        [-np.sin(theta), np.sin(phi) * np.cos(theta), np.cos(phi) * np.cos(theta)]\n        ])\n\n    def get_euler_rates(self, angular_vel = None):\n        \"\"\"\n        Get the euler rates from the angular velocity vector.\n        Parameters\n        ----------\n        angular_vel : np.ndarray, optional\n            Angular velocity vector (p, q, r). If None, uses current state.\n        \"\"\"\n        if angular_vel is None:\n            angular_vel = self.angular_vel\n        return np.dot(self.T_angularVel_to_EulerRates, angular_vel)\n\n    def get_angular_vel_skew(self, angular_vel = None):\n        \"\"\"\n        Get the skew symmetric matrix of the angular velocity vector.\n        \"\"\"\n        if angular_vel is None:\n            p, q, r = self.angular_vel\n        else:\n            p, q, r = angular_vel\n        return np.array([\n            [0, -r, q],\n            [r, 0, -p],\n            [-q, p, 0]\n        ])\n\n    def get_angular_vel_to_EulerRates_matrix(self, euler_angles = None):\n        \"\"\"\n        Get the transformation matrix from angular velocity to euler rates.\n        Parameters\n        ----------\n        euler_angles : tuple or list, optional\n            Euler angles (phi, theta, psi) in radians. If None, uses current state.\n        Returns\n        -------\n        np.ndarray\n            3x3 transformation matrix.\n        \"\"\"\n        if euler_angles is None:\n            phi, theta, psi = self.eulers\n        else:\n            phi, theta, psi = euler_angles\n        if abs(theta - np.pi/2) &lt; 0.1:\n            self.error = True\n            # print(\"theta is close to 90.\")\n            theta = np.pi/2 * 0.999\n        return np.array([\n            [1, np.sin(phi) * np.tan(theta), np.cos(phi) * np.tan(theta)],\n            [0, np.cos(phi), -np.sin(phi)],\n            [0, np.sin(phi) / np.cos(theta), np.cos(phi) / np.cos(theta)]\n        ])\n\n    def update_kinematic_transforations(self, euler_angles = None, angular_vel = None):\n        \"\"\"\n        Update the kinematic transformations based on the current state.\n        Parameters\n        ----------\n        euler_angles : tuple or list, optional\n            Euler angles (phi, theta, psi) in radians. If None, uses current state.\n        angular_vel : np.ndarray, optional\n            Angular velocity vector (p, q, r). If None, uses current state.\n        \"\"\"\n        if euler_angles is None:\n            euler_angles = self.eulers\n        if angular_vel is None:\n            angular_vel = self.angular_vel\n        self.CDM = self.get_CDM(euler_angles)\n        self.angular_vel_skew = self.get_angular_vel_skew(angular_vel)\n        self.T_angularVel_to_EulerRates = self.get_angular_vel_to_EulerRates_matrix(euler_angles)\n\n    def update_wind_transformations(self):\n        \"\"\"\n        Update the wind-related transformations based on the current state.\n        Calculates local airspeed, angle of attack, sideslip angle, and rotation matrix from wind to body frame.\n        \"\"\"\n        epsilon = 1e-8  # small value to prevent division by zero\n        # calculate local airspeed in body fixed frame\n        self.va = self.vb - self.body_to_inertial(self.w, True) # local airspeed in body fixed frame\n        if np.all(np.isfinite(self.va)):\n            self.va_mag = np.linalg.norm(self.va) # magnitude of the local airspeed in body fixed frame\n        else:\n            self.error = True\n            #print(f\"Warning: Invalid airspeed vector: va={self.va}, vb = {self.vb}\")\n            self.va = np.array([epsilon,epsilon,epsilon])\n            self.va_mag = epsilon \n\n\n\n        # Angle of attack: arctangent of vertical to forward airspeed\n        self.angle_of_attack = np.arctan2(self.va[2], self.va[0] if abs(self.va[0]) &gt; epsilon else epsilon * np.sign(self.va[0]))\n\n        # Sideslip angle: arctangent of lateral to horizontal (forward + vertical) airspeed\n        denom = np.sqrt(self.va[0]**2 + self.va[2]**2)\n        denom_safe = denom if denom &gt; epsilon else epsilon\n        self.sideslip_angle = np.arctan2(self.va[1], denom_safe)\n\n        # calculate the rotation matrix wind to body\n        self.R_wb = np.array([\n            [np.cos(self.angle_of_attack) * np.cos(self.sideslip_angle), -np.sin(self.sideslip_angle), np.cos(self.sideslip_angle) * np.sin(self.angle_of_attack)],\n            [np.sin(self.angle_of_attack) * np.cos(self.sideslip_angle), np.cos(self.angle_of_attack), np.sin(self.angle_of_attack) * np.sin(self.sideslip_angle)],\n            [-np.sin(self.angle_of_attack), 0, np.cos(self.angle_of_attack)]\n        ])\n\n    def body_to_inertial(self,vector, inverse = False):\n        \"\"\"\n        Rotate a vector from body frame to inertial\n\n        Parameters\n        ----------\n        vector : np.ndarray\n            3D vector in body frame.\n        inverse : bool, optional\n            If True, rotates from inertial to body frame. Default is False.\n        Returns\n        -------\n        np.ndarray\n            Rotated 3D vector.\"\"\"\n        R_bi = self.CDM.T if inverse else self.CDM\n        return np.dot(R_bi, vector)\n\n    def body_to_wind(self,vector, inverse = False):\n        \"\"\"\n        Rotate a vector from body frame to wind frame.\n        Parameters\n        ----------\n        vector : np.ndarray\n            3D vector in body frame.\n        inverse : bool, optional\n            If True, rotates from wind to body frame. Default is False.\n        Returns\n        -------\n        np.ndarray\n            Rotated 3D vector.\n        \"\"\"\n        R_bw = self.R_wb if inverse else self.R_wb.T\n        return np.dot(R_bw, vector)\n\n    def calculate_aero_force_coeff(self):\n        \"\"\"\n        calculates the combined areodynamic force coefficients. Uses AoA, rigging angles etc.\n\n        Returns\n        -------\n        list\n            [CD, CY, CL] aerodynamic force coefficients.\n        \"\"\"\n        # for lifting\n        self.CL = self.CLo + self.CLa * (self.angle_of_attack + self.rigging_angle) + self.CL_sym*self.delta_s\n\n        # for drag\n        self.CD = self.CDo + self.CDa * (self.angle_of_attack + self.rigging_angle)\n\n        # for side force\n        self.CY = - self.CYB * self.sideslip_angle\n\n        return [self.CD, self.CY, self.CL]\n\n    def calculate_aero_moment_coeff(self):\n        \"\"\"\n        calculates the combined areodynamic moment coefficients. Uses AoA, rigging angles etc.\n\n        Returns\n        -------\n        list\n            [Cl, Cm, Cn] aerodynamic moments coefficients.\n        \"\"\"\n        # for rolling\n        self.Cl = self.ClB * self.sideslip_angle + self.Cl_asym * self.delta_a + \\\n                    self.Clp * self.c/(2*self.va_mag) * self.angular_vel[0]+ \\\n                    self.Clr * self.c/(2*self.va_mag) * self.angular_vel[2] \n\n        # for pitching\n        self.Cm = self.Cmo + self.Cma * (self.angle_of_attack + self.rigging_angle) + \\\n                    self.Cmq * self.c/(2*self.va_mag) * self.angular_vel[1]\n\n        # for yawing\n        self.Cn = self.CnB * self.sideslip_angle + self.Cn_asym * self.delta_a + \\\n                    self.Cn_p * self.c/(2*self.va_mag) * self.angular_vel[0] + \\\n                    self.Cn_r * self.c/(2*self.va_mag) * self.angular_vel[2]\n\n        return [self.Cl, self.Cm, self.Cn]\n\n    def calculate_aero_forces(self):\n        \"\"\"\n        Calculates the aerodynamic forces in the body frame.\n        Returns\n        -------\n        np.ndarray\n            Aerodynamic force vector in body frame.\n        \"\"\"\n        self.calculate_aero_force_coeff()\n        # calculate the components\n        Fa_x = 0.5 * p_density * self.va_mag**2 * self.S * self.CD\n        Fa_y = 0.5 * p_density * self.va_mag**2 * self.S * self.CY\n        Fa_z = 0.5 * p_density * self.va_mag**2 * self.S * self.CL\n\n        F_aero_A = np.array([Fa_x,Fa_y,Fa_z])\n        F_aero_A = self.safe_clamp_vector(F_aero_A)\n        # rotate forces to the body frame and negify\n        self.F_aero = - self.body_to_wind(F_aero_A, False)\n        return self.F_aero\n\n    def calculate_aero_moments(self):\n        \"\"\"\n        Calculates the aerodynamic moments in the body frame.\n        Returns\n        -------\n        np.ndarray\n            Aerodynamic moment vector in body frame.\n        \"\"\"\n        self.calculate_aero_moment_coeff()\n\n        L = 0.5 * p_density * self.va_mag**2 * self.S * self.b * self.Cl\n        M = 0.5 * p_density * self.va_mag**2 * self.S * self.c * self.Cm\n        N = 0.5 * p_density * self.va_mag**2 * self.S * self.b * self.Cn\n        # since \n        M_aero_A = np.array([L,M,N])\n        M_aero_A = self.safe_clamp_vector(M_aero_A)\n        # rotate moments to the body frame\n        # self.M_aero = self.body_to_wind(M_aero_A,True)\n        self.M_aero = M_aero_A\n        return self.M_aero\n\n    def calculate_derivatives(self):\n        \"\"\"\n        Calculate the derivatives of the state vector. This also calculates all the forces and moments.\n        Returns\n        -------\n        list\n            [acceleration_body, angular_acceleration].\"\"\"   \n        # calculate the aero forces\n        F_aero = self.calculate_aero_forces()\n\n        # calculate the gravity force\n        # theta, phi = self.eulers[1], self.eulers[2]\n        self.F_g = self.body_to_inertial([0,0,self.m*9.81],True)\n\n        # calculate acceleration\n        self.F_fictious = 0 - self.m * np.dot(self.angular_vel_skew, self.vb)\n        F_total = F_aero + self.F_g + self.F_fictious\n        self.acc = F_total / self.m\n\n\n        # calculate the aerodynamic moments\n        self.calculate_aero_moments()\n        #print(\"     M_aero: \", M_aero)\n        # calculate the moments due to aerodynamic forces\n        self.M_f_aero = np.cross(self.Rp,F_aero)\n        #print(\"     M_f_aero: \", M_f_aero)\n        # calculate the anglular acceleration\n        self.M_fictious = - np.dot(self.angular_vel_skew, np.dot(self.I, self.angular_vel))\n        self.M_total = self.M_aero + self.M_fictious\n        I_inv = np.linalg.inv(self.I)\n        self.angular_acc = np.dot(I_inv,self.M_total)\n        return [self.acc,self.angular_acc]\n\n    def calculate_apparent_mass_matrices(self):\n        \"\"\"\n        Calculates the apparent mass matrix for the parafoil. Note this isnt functioning\"\"\"\n            # Correlation factors for flat parafoil\n\n        AR = self.b/self.c\n        R = np.sqrt((self.b/2)**2 + np.linalg.norm(self.Rp)**2) # line length\n        k_A  = 0.848\n        k_B  = 0.34  # use avg or upper bound of 1.24 if needed\n        k_C  = AR / (1 + AR)\n\n        # 3D corrected factors\n        k_A_star  = 0.84 * AR / (1 + AR)\n        k_B_star  = 1.161 * AR / (1 + AR)\n        k_C_star  = 0.848\n\n        # Apparent mass (flat parafoil)\n        m_x_flat = self.rho * k_A  * (np.pi / 4) * self.t**2 * self.b\n        m_y_flat = self.rho * k_B  * (np.pi / 4) * self.t**2 * self.c\n        m_z_flat = self.rho * k_C  * (np.pi / 4) * self.c**2 * self.b\n\n        # Apparent moments of inertia (flat parafoil)\n        I_x_flat = self.rho * k_A  * (np.pi / 48) * self.c**2 * self.b**3\n        I_y_flat = self.rho * k_B  * (np.pi / 48) * self.c**4 * self.b\n        I_z_flat = self.rho * k_C  * (np.pi / 48) * self.t**2 * self.b**3\n\n                # Geometry\n        a_bar = (R - R * np.cos(e0)) / (2 * R * np.sin(e0))  # Mean curvature\n        a1 = self.c / 2\n        a2 = self.b / 2\n\n        # Apparent Masses\n        m_x = m_x_flat * (1 + (8/3) * a_bar**2)\n        m_y = (1 / a1**2) * (R**2 * m_y_flat + I_x_flat)\n        m_z = m_z_flat * np.sqrt(1 + 2 * a_bar**2 * (1 - self.t**2))\n\n        # Apparent Moments of Inertia\n        I_x = (a1**2 / a1**2) * R**2 * m_y_flat + (a2**2 / a1**2) * I_x_flat\n        I_y = I_y_flat * (1 + (np.pi / 6) * (1 + AR) * AR * a_bar**2 * self.t**2)\n        I_z = (1 + 8 * a_bar**2) * I_z_flat\n\n        I_am = np.dot(np.identity(3),[m_x,m_y,m_z])\n        I_ai = np.dot(np.identity(3),[I_x,I_y,I_z])\n\n    def calculate_moments_of_inertia(self):\n        \"\"\"\n        Computes the moments of inertia of system in the body frame.\n\n        Parameters\n        ----------\n            R: 3x3 numpy array\n                Rotation matrix from parafoil frame to body frame.\n\n        Returns\n        -------\n            I_rotated: 3x3 numpy array\n                Inertia tensor in the rotated frame.\n        \"\"\"\n        # Principle moments of inertia of the parafoil\n        Ix_parafoil = 1.0\n        Iy_parafoil = 2.0\n        Iz_parafoil = 3.0\n        # Rotation matrix from parafoil frame to body frame\n        R = np.array([\n            [np.cos(self.rigging_angle), 0, np.sin(self.rigging_angle)],\n            [0, 1, 0],\n            [-np.sin(self.rigging_angle), 0, np.cos(self.rigging_angle)]\n        ])\n\n        # Principle inertia tensor\n        I_parafoil = np.diag([Ix_parafoil, Iy_parafoil, Iz_parafoil])\n\n        # Rotate into the new frame\n        I_rotated_parafoil = R @ I_parafoil @ R.T\n\n        # ___________ payload moment of inertia _____________\n\n        # define the inertia tensor of the payload, atm assume to be cylindrical\n        Ix_payload = 0.1\n        Iy_payload = 0.1\n        Iz_payload = 0.1\n\n        # principle inertia tensor of the payload\n        I_payload = np.diag([Ix_payload, Iy_payload, Iz_payload])\n\n        # ___________ Inertias at coM  _____________\n        # calculate the inertia tensor at the center of mass\n        # CoM of the system assumed to be at coM of Payload\n        # use parallel axis theorem to represent parafoil tensor at coM of system\n\n        # distance between parafoil and payload\n        d = np.array([0, 0, self.Rp])\n        d_outer = np.outer(d, d)\n        I_parafoil_at_com = I_rotated_parafoil + self.parafoil_mass * ((np.dot(d, d) * np.eye(3)) - d_outer)\n\n        # calculate the inertia tensor at the center of mass\n        self.I = I_parafoil_at_com + I_payload\n\n    def get_solver_derivatives(self,state):\n        \"\"\"\n        This function is used by the ODE solver to get the derivatives of the state vector.\n\n        Parameters\n        ----------\n        state : list\n            State vector [position, velocity_body, eulers, angular_velocity].\n\n        Returns\n        -------\n        list\n            Derivatives of the state vector [velocity_body, acceleration_body, euler_rates, angular_acceleration].\"\"\"\n        old_state = self.get_state()\n        self.set_state(state)\n        # Calculate the derivatives\n        self.calculate_derivatives() \n        # get eular rates\n        euler_rates = np.dot(self.T_angularVel_to_EulerRates, self.angular_vel)\n        # deritives for the vars: [position, velocity, euler angles, angular velocity]\n        derivatives = [self.body_to_inertial(self.vb),self.acc,euler_rates,self.angular_acc]\n        # Reset the simulation state to the original\n        self.set_state(old_state)\n        return derivatives\n\n    def safe_clamp_vector(self, vec, max_abs=1e3):\n        \"\"\"\n        Clamp a 3D vector to avoid NaN, inf, and excessively large values.\n\n        Parameters\n        ----------\n            vec (np.ndarray): Input 3D vector.\n            max_abs (float): Maximum allowed absolute value for each component.\n\n        Returns\n        -------\n            np.ndarray: A safe, clamped 3D vector.\n        \"\"\"\n        safe_vec = np.zeros(3)\n\n        for i in range(3):\n            val = vec[i]\n            if not np.isfinite(val):\n                #print(\"clamping\")\n                self.error = True\n                safe_vec[i] = 0.0\n            elif abs(val) &gt; max_abs:\n                #print()\n                self.error = True\n                safe_vec[i] = np.clip(val, -max_abs, max_abs)\n            else:\n                safe_vec[i] = val\n\n        return safe_vec\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.__init__","title":"<code>__init__(params, state, inputs)</code>","text":"<p>Initialize the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>System parameters such as mass, geometry, and aerodynamic coefficients.</p> required <code>state</code> <code>list</code> <p>Initial state vector [position, velocity_body, eulers, angular_velocity].</p> required <code>inputs</code> <code>list</code> <p>Simulation inputs [flap deflection angles, wind vector].</p> required Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def __init__(self,params,state, inputs):\n    \"\"\"\n    Initialize the simulation.\n\n    Parameters\n    ----------\n    params : dict\n        System parameters such as mass, geometry, and aerodynamic coefficients.\n\n    state : list\n        Initial state vector [position, velocity_body, eulers, angular_velocity].\n\n    inputs : list\n        Simulation inputs [flap deflection angles, wind vector].\n    \"\"\"\n    self.set_system_params(params)\n    self.set_inputs(inputs)\n    self.set_state(state)\n    self.error = False\n    # calculate the derivatives\n    self.calculate_derivatives()\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.body_to_inertial","title":"<code>body_to_inertial(vector, inverse=False)</code>","text":"<p>Rotate a vector from body frame to inertial</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray</code> <p>3D vector in body frame.</p> required <code>inverse</code> <code>bool</code> <p>If True, rotates from inertial to body frame. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Rotated 3D vector.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def body_to_inertial(self,vector, inverse = False):\n    \"\"\"\n    Rotate a vector from body frame to inertial\n\n    Parameters\n    ----------\n    vector : np.ndarray\n        3D vector in body frame.\n    inverse : bool, optional\n        If True, rotates from inertial to body frame. Default is False.\n    Returns\n    -------\n    np.ndarray\n        Rotated 3D vector.\"\"\"\n    R_bi = self.CDM.T if inverse else self.CDM\n    return np.dot(R_bi, vector)\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.body_to_wind","title":"<code>body_to_wind(vector, inverse=False)</code>","text":"<p>Rotate a vector from body frame to wind frame.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray</code> <p>3D vector in body frame.</p> required <code>inverse</code> <code>bool</code> <p>If True, rotates from wind to body frame. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Rotated 3D vector.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def body_to_wind(self,vector, inverse = False):\n    \"\"\"\n    Rotate a vector from body frame to wind frame.\n    Parameters\n    ----------\n    vector : np.ndarray\n        3D vector in body frame.\n    inverse : bool, optional\n        If True, rotates from wind to body frame. Default is False.\n    Returns\n    -------\n    np.ndarray\n        Rotated 3D vector.\n    \"\"\"\n    R_bw = self.R_wb if inverse else self.R_wb.T\n    return np.dot(R_bw, vector)\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.calculate_aero_force_coeff","title":"<code>calculate_aero_force_coeff()</code>","text":"<p>calculates the combined areodynamic force coefficients. Uses AoA, rigging angles etc.</p> <p>Returns:</p> Type Description <code>list</code> <p>[CD, CY, CL] aerodynamic force coefficients.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def calculate_aero_force_coeff(self):\n    \"\"\"\n    calculates the combined areodynamic force coefficients. Uses AoA, rigging angles etc.\n\n    Returns\n    -------\n    list\n        [CD, CY, CL] aerodynamic force coefficients.\n    \"\"\"\n    # for lifting\n    self.CL = self.CLo + self.CLa * (self.angle_of_attack + self.rigging_angle) + self.CL_sym*self.delta_s\n\n    # for drag\n    self.CD = self.CDo + self.CDa * (self.angle_of_attack + self.rigging_angle)\n\n    # for side force\n    self.CY = - self.CYB * self.sideslip_angle\n\n    return [self.CD, self.CY, self.CL]\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.calculate_aero_forces","title":"<code>calculate_aero_forces()</code>","text":"<p>Calculates the aerodynamic forces in the body frame.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Aerodynamic force vector in body frame.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def calculate_aero_forces(self):\n    \"\"\"\n    Calculates the aerodynamic forces in the body frame.\n    Returns\n    -------\n    np.ndarray\n        Aerodynamic force vector in body frame.\n    \"\"\"\n    self.calculate_aero_force_coeff()\n    # calculate the components\n    Fa_x = 0.5 * p_density * self.va_mag**2 * self.S * self.CD\n    Fa_y = 0.5 * p_density * self.va_mag**2 * self.S * self.CY\n    Fa_z = 0.5 * p_density * self.va_mag**2 * self.S * self.CL\n\n    F_aero_A = np.array([Fa_x,Fa_y,Fa_z])\n    F_aero_A = self.safe_clamp_vector(F_aero_A)\n    # rotate forces to the body frame and negify\n    self.F_aero = - self.body_to_wind(F_aero_A, False)\n    return self.F_aero\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.calculate_aero_moment_coeff","title":"<code>calculate_aero_moment_coeff()</code>","text":"<p>calculates the combined areodynamic moment coefficients. Uses AoA, rigging angles etc.</p> <p>Returns:</p> Type Description <code>list</code> <p>[Cl, Cm, Cn] aerodynamic moments coefficients.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def calculate_aero_moment_coeff(self):\n    \"\"\"\n    calculates the combined areodynamic moment coefficients. Uses AoA, rigging angles etc.\n\n    Returns\n    -------\n    list\n        [Cl, Cm, Cn] aerodynamic moments coefficients.\n    \"\"\"\n    # for rolling\n    self.Cl = self.ClB * self.sideslip_angle + self.Cl_asym * self.delta_a + \\\n                self.Clp * self.c/(2*self.va_mag) * self.angular_vel[0]+ \\\n                self.Clr * self.c/(2*self.va_mag) * self.angular_vel[2] \n\n    # for pitching\n    self.Cm = self.Cmo + self.Cma * (self.angle_of_attack + self.rigging_angle) + \\\n                self.Cmq * self.c/(2*self.va_mag) * self.angular_vel[1]\n\n    # for yawing\n    self.Cn = self.CnB * self.sideslip_angle + self.Cn_asym * self.delta_a + \\\n                self.Cn_p * self.c/(2*self.va_mag) * self.angular_vel[0] + \\\n                self.Cn_r * self.c/(2*self.va_mag) * self.angular_vel[2]\n\n    return [self.Cl, self.Cm, self.Cn]\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.calculate_aero_moments","title":"<code>calculate_aero_moments()</code>","text":"<p>Calculates the aerodynamic moments in the body frame.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Aerodynamic moment vector in body frame.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def calculate_aero_moments(self):\n    \"\"\"\n    Calculates the aerodynamic moments in the body frame.\n    Returns\n    -------\n    np.ndarray\n        Aerodynamic moment vector in body frame.\n    \"\"\"\n    self.calculate_aero_moment_coeff()\n\n    L = 0.5 * p_density * self.va_mag**2 * self.S * self.b * self.Cl\n    M = 0.5 * p_density * self.va_mag**2 * self.S * self.c * self.Cm\n    N = 0.5 * p_density * self.va_mag**2 * self.S * self.b * self.Cn\n    # since \n    M_aero_A = np.array([L,M,N])\n    M_aero_A = self.safe_clamp_vector(M_aero_A)\n    # rotate moments to the body frame\n    # self.M_aero = self.body_to_wind(M_aero_A,True)\n    self.M_aero = M_aero_A\n    return self.M_aero\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.calculate_apparent_mass_matrices","title":"<code>calculate_apparent_mass_matrices()</code>","text":"<p>Calculates the apparent mass matrix for the parafoil. Note this isnt functioning</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def calculate_apparent_mass_matrices(self):\n    \"\"\"\n    Calculates the apparent mass matrix for the parafoil. Note this isnt functioning\"\"\"\n        # Correlation factors for flat parafoil\n\n    AR = self.b/self.c\n    R = np.sqrt((self.b/2)**2 + np.linalg.norm(self.Rp)**2) # line length\n    k_A  = 0.848\n    k_B  = 0.34  # use avg or upper bound of 1.24 if needed\n    k_C  = AR / (1 + AR)\n\n    # 3D corrected factors\n    k_A_star  = 0.84 * AR / (1 + AR)\n    k_B_star  = 1.161 * AR / (1 + AR)\n    k_C_star  = 0.848\n\n    # Apparent mass (flat parafoil)\n    m_x_flat = self.rho * k_A  * (np.pi / 4) * self.t**2 * self.b\n    m_y_flat = self.rho * k_B  * (np.pi / 4) * self.t**2 * self.c\n    m_z_flat = self.rho * k_C  * (np.pi / 4) * self.c**2 * self.b\n\n    # Apparent moments of inertia (flat parafoil)\n    I_x_flat = self.rho * k_A  * (np.pi / 48) * self.c**2 * self.b**3\n    I_y_flat = self.rho * k_B  * (np.pi / 48) * self.c**4 * self.b\n    I_z_flat = self.rho * k_C  * (np.pi / 48) * self.t**2 * self.b**3\n\n            # Geometry\n    a_bar = (R - R * np.cos(e0)) / (2 * R * np.sin(e0))  # Mean curvature\n    a1 = self.c / 2\n    a2 = self.b / 2\n\n    # Apparent Masses\n    m_x = m_x_flat * (1 + (8/3) * a_bar**2)\n    m_y = (1 / a1**2) * (R**2 * m_y_flat + I_x_flat)\n    m_z = m_z_flat * np.sqrt(1 + 2 * a_bar**2 * (1 - self.t**2))\n\n    # Apparent Moments of Inertia\n    I_x = (a1**2 / a1**2) * R**2 * m_y_flat + (a2**2 / a1**2) * I_x_flat\n    I_y = I_y_flat * (1 + (np.pi / 6) * (1 + AR) * AR * a_bar**2 * self.t**2)\n    I_z = (1 + 8 * a_bar**2) * I_z_flat\n\n    I_am = np.dot(np.identity(3),[m_x,m_y,m_z])\n    I_ai = np.dot(np.identity(3),[I_x,I_y,I_z])\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.calculate_derivatives","title":"<code>calculate_derivatives()</code>","text":"<p>Calculate the derivatives of the state vector. This also calculates all the forces and moments.</p> <p>Returns:</p> Type Description <code>list</code> <p>[acceleration_body, angular_acceleration].</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def calculate_derivatives(self):\n    \"\"\"\n    Calculate the derivatives of the state vector. This also calculates all the forces and moments.\n    Returns\n    -------\n    list\n        [acceleration_body, angular_acceleration].\"\"\"   \n    # calculate the aero forces\n    F_aero = self.calculate_aero_forces()\n\n    # calculate the gravity force\n    # theta, phi = self.eulers[1], self.eulers[2]\n    self.F_g = self.body_to_inertial([0,0,self.m*9.81],True)\n\n    # calculate acceleration\n    self.F_fictious = 0 - self.m * np.dot(self.angular_vel_skew, self.vb)\n    F_total = F_aero + self.F_g + self.F_fictious\n    self.acc = F_total / self.m\n\n\n    # calculate the aerodynamic moments\n    self.calculate_aero_moments()\n    #print(\"     M_aero: \", M_aero)\n    # calculate the moments due to aerodynamic forces\n    self.M_f_aero = np.cross(self.Rp,F_aero)\n    #print(\"     M_f_aero: \", M_f_aero)\n    # calculate the anglular acceleration\n    self.M_fictious = - np.dot(self.angular_vel_skew, np.dot(self.I, self.angular_vel))\n    self.M_total = self.M_aero + self.M_fictious\n    I_inv = np.linalg.inv(self.I)\n    self.angular_acc = np.dot(I_inv,self.M_total)\n    return [self.acc,self.angular_acc]\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.calculate_moments_of_inertia","title":"<code>calculate_moments_of_inertia()</code>","text":"<p>Computes the moments of inertia of system in the body frame.</p> <p>Returns:</p> Type Description <code>    I_rotated: 3x3 numpy array</code> <p>Inertia tensor in the rotated frame.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def calculate_moments_of_inertia(self):\n    \"\"\"\n    Computes the moments of inertia of system in the body frame.\n\n    Parameters\n    ----------\n        R: 3x3 numpy array\n            Rotation matrix from parafoil frame to body frame.\n\n    Returns\n    -------\n        I_rotated: 3x3 numpy array\n            Inertia tensor in the rotated frame.\n    \"\"\"\n    # Principle moments of inertia of the parafoil\n    Ix_parafoil = 1.0\n    Iy_parafoil = 2.0\n    Iz_parafoil = 3.0\n    # Rotation matrix from parafoil frame to body frame\n    R = np.array([\n        [np.cos(self.rigging_angle), 0, np.sin(self.rigging_angle)],\n        [0, 1, 0],\n        [-np.sin(self.rigging_angle), 0, np.cos(self.rigging_angle)]\n    ])\n\n    # Principle inertia tensor\n    I_parafoil = np.diag([Ix_parafoil, Iy_parafoil, Iz_parafoil])\n\n    # Rotate into the new frame\n    I_rotated_parafoil = R @ I_parafoil @ R.T\n\n    # ___________ payload moment of inertia _____________\n\n    # define the inertia tensor of the payload, atm assume to be cylindrical\n    Ix_payload = 0.1\n    Iy_payload = 0.1\n    Iz_payload = 0.1\n\n    # principle inertia tensor of the payload\n    I_payload = np.diag([Ix_payload, Iy_payload, Iz_payload])\n\n    # ___________ Inertias at coM  _____________\n    # calculate the inertia tensor at the center of mass\n    # CoM of the system assumed to be at coM of Payload\n    # use parallel axis theorem to represent parafoil tensor at coM of system\n\n    # distance between parafoil and payload\n    d = np.array([0, 0, self.Rp])\n    d_outer = np.outer(d, d)\n    I_parafoil_at_com = I_rotated_parafoil + self.parafoil_mass * ((np.dot(d, d) * np.eye(3)) - d_outer)\n\n    # calculate the inertia tensor at the center of mass\n    self.I = I_parafoil_at_com + I_payload\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.check_set_param","title":"<code>check_set_param(dict, param_name)</code>","text":"<p>Check if the parameter is set in the dictionary and if its type matches the expected type. If so, sets the instance variable self. to the value from the dictionary. <p>Parameters:</p> Name Type Description Default <code>dict</code> <code>dict</code> <p>Dictionary containing parameters of the simulation.</p> required <code>param_name</code> <code>str</code> <p>Name of the parameter to check and set.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the parameter was found and set, False otherwise.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def check_set_param(self, dict, param_name):\n    \"\"\"\n    Check if the parameter is set in the dictionary and if its type matches the expected type.\n    If so, sets the instance variable self.&lt;attr_name&gt; to the value from the dictionary.\n\n    Parameters\n    ----------\n    dict : dict\n        Dictionary containing parameters of the simulation.\n    param_name : str\n        Name of the parameter to check and set.\n\n    Returns\n    -------\n    bool\n        True if the parameter was found and set, False otherwise.\n    \"\"\"\n    param = dict.get(param_name)\n    if param is None:\n        return False\n    elif not hasattr(self, param_name):\n        raise AttributeError(f\"Attribute '{param_name}' does not exist on the instance.\")\n    elif type(getattr(self, param_name)) != type(param):\n        raise TypeError(f\"Parameter '{param_name}' should be of type {type(getattr(self, param_name))}. Got {type(param)} instead.\")\n\n    setattr(self, param_name, param)\n\n    # print(f\"Set {param_name} to {param}\")\n    return True\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.get_CDM","title":"<code>get_CDM(euler_angles=None)</code>","text":"<p>Get the rotation matrix from body to inertial frame</p> <p>Parameters:</p> Name Type Description Default <code>euler_angles</code> <code>tuple or list</code> <p>Euler angles (phi, theta, psi) in radians. If None, uses current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def get_CDM(self, euler_angles = None):\n    \"\"\"\n    Get the rotation matrix from body to inertial frame\n    Parameters\n    ----------\n    euler_angles : tuple or list, optional\n        Euler angles (phi, theta, psi) in radians. If None, uses current state.\n\n    Returns\n    -------\n    np.ndarray\n        3x3 rotation matrix.\"\"\"\n\n    if euler_angles is None:\n        phi, theta, psi = self.eulers\n    else:\n        phi, theta, psi = euler_angles\n    return np.array([\n    [np.cos(theta) * np.cos(psi), np.sin(phi) * np.sin(theta) * np.cos(psi) - np.cos(phi) * np.sin(psi), np.cos(phi) * np.sin(theta) * np.cos(psi) + np.sin(phi) * np.sin(psi)],\n    [np.cos(theta) * np.sin(psi), np.sin(phi) * np.sin(theta) * np.sin(psi) + np.cos(phi) * np.cos(psi), np.cos(phi) * np.sin(theta) * np.sin(psi) - np.sin(phi) * np.cos(psi)],\n    [-np.sin(theta), np.sin(phi) * np.cos(theta), np.cos(phi) * np.cos(theta)]\n    ])\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.get_angular_vel_skew","title":"<code>get_angular_vel_skew(angular_vel=None)</code>","text":"<p>Get the skew symmetric matrix of the angular velocity vector.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def get_angular_vel_skew(self, angular_vel = None):\n    \"\"\"\n    Get the skew symmetric matrix of the angular velocity vector.\n    \"\"\"\n    if angular_vel is None:\n        p, q, r = self.angular_vel\n    else:\n        p, q, r = angular_vel\n    return np.array([\n        [0, -r, q],\n        [r, 0, -p],\n        [-q, p, 0]\n    ])\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.get_angular_vel_to_EulerRates_matrix","title":"<code>get_angular_vel_to_EulerRates_matrix(euler_angles=None)</code>","text":"<p>Get the transformation matrix from angular velocity to euler rates.</p> <p>Parameters:</p> Name Type Description Default <code>euler_angles</code> <code>tuple or list</code> <p>Euler angles (phi, theta, psi) in radians. If None, uses current state.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 transformation matrix.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def get_angular_vel_to_EulerRates_matrix(self, euler_angles = None):\n    \"\"\"\n    Get the transformation matrix from angular velocity to euler rates.\n    Parameters\n    ----------\n    euler_angles : tuple or list, optional\n        Euler angles (phi, theta, psi) in radians. If None, uses current state.\n    Returns\n    -------\n    np.ndarray\n        3x3 transformation matrix.\n    \"\"\"\n    if euler_angles is None:\n        phi, theta, psi = self.eulers\n    else:\n        phi, theta, psi = euler_angles\n    if abs(theta - np.pi/2) &lt; 0.1:\n        self.error = True\n        # print(\"theta is close to 90.\")\n        theta = np.pi/2 * 0.999\n    return np.array([\n        [1, np.sin(phi) * np.tan(theta), np.cos(phi) * np.tan(theta)],\n        [0, np.cos(phi), -np.sin(phi)],\n        [0, np.sin(phi) / np.cos(theta), np.cos(phi) / np.cos(theta)]\n    ])\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.get_euler_rates","title":"<code>get_euler_rates(angular_vel=None)</code>","text":"<p>Get the euler rates from the angular velocity vector.</p> <p>Parameters:</p> Name Type Description Default <code>angular_vel</code> <code>ndarray</code> <p>Angular velocity vector (p, q, r). If None, uses current state.</p> <code>None</code> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def get_euler_rates(self, angular_vel = None):\n    \"\"\"\n    Get the euler rates from the angular velocity vector.\n    Parameters\n    ----------\n    angular_vel : np.ndarray, optional\n        Angular velocity vector (p, q, r). If None, uses current state.\n    \"\"\"\n    if angular_vel is None:\n        angular_vel = self.angular_vel\n    return np.dot(self.T_angularVel_to_EulerRates, angular_vel)\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.get_inertial_position","title":"<code>get_inertial_position()</code>","text":"<p>Get the position in the inertial frame.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Position in the inertial frame.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def get_inertial_position(self):\n    \"\"\"\n    Get the position in the inertial frame.\n    Returns\n    -------\n    np.ndarray\n        Position in the inertial frame.\n    \"\"\"\n    ned_to_world = np.array([1, 1, -1])  # Flip Z-axis\n    inertial_pos = self.initial_pos + ned_to_world * self.p  # Element-wise multiplication\n    return inertial_pos\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.get_inertial_state","title":"<code>get_inertial_state()</code>","text":"<p>Get the current state vector in the inertial frame.</p> <p>Returns:</p> Type Description <code>list</code> <p>[position_inertial, velocity_inertial, eulers, euler_rates].</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def get_inertial_state(self):\n    \"\"\"\n    Get the current state vector in the inertial frame.\n    Returns\n    -------\n    list\n        [position_inertial, velocity_inertial, eulers, euler_rates].\n    \"\"\"\n\n    return[self.get_inertial_position(), self.body_to_inertial(self.vb), self.eulers, self.get_euler_rates()]\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.get_solver_derivatives","title":"<code>get_solver_derivatives(state)</code>","text":"<p>This function is used by the ODE solver to get the derivatives of the state vector.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>list</code> <p>State vector [position, velocity_body, eulers, angular_velocity].</p> required <p>Returns:</p> Type Description <code>list</code> <p>Derivatives of the state vector [velocity_body, acceleration_body, euler_rates, angular_acceleration].</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def get_solver_derivatives(self,state):\n    \"\"\"\n    This function is used by the ODE solver to get the derivatives of the state vector.\n\n    Parameters\n    ----------\n    state : list\n        State vector [position, velocity_body, eulers, angular_velocity].\n\n    Returns\n    -------\n    list\n        Derivatives of the state vector [velocity_body, acceleration_body, euler_rates, angular_acceleration].\"\"\"\n    old_state = self.get_state()\n    self.set_state(state)\n    # Calculate the derivatives\n    self.calculate_derivatives() \n    # get eular rates\n    euler_rates = np.dot(self.T_angularVel_to_EulerRates, self.angular_vel)\n    # deritives for the vars: [position, velocity, euler angles, angular velocity]\n    derivatives = [self.body_to_inertial(self.vb),self.acc,euler_rates,self.angular_acc]\n    # Reset the simulation state to the original\n    self.set_state(old_state)\n    return derivatives\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.get_state","title":"<code>get_state()</code>","text":"<p>Get the current state vector.</p> <p>Returns:</p> Type Description <code>list</code> <p>[position, velocity_body, eulers, angular_velocity].</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def get_state(self):\n    \"\"\"\n    Get the current state vector.\n\n    Returns\n    -------\n    list\n        [position, velocity_body, eulers, angular_velocity].\n    \"\"\"\n    return [self.p, self.vb, self.eulers, self.angular_vel]\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.safe_clamp_vector","title":"<code>safe_clamp_vector(vec, max_abs=1000.0)</code>","text":"<p>Clamp a 3D vector to avoid NaN, inf, and excessively large values.</p> <p>Returns:</p> Type Description <code>    np.ndarray: A safe, clamped 3D vector.</code> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def safe_clamp_vector(self, vec, max_abs=1e3):\n    \"\"\"\n    Clamp a 3D vector to avoid NaN, inf, and excessively large values.\n\n    Parameters\n    ----------\n        vec (np.ndarray): Input 3D vector.\n        max_abs (float): Maximum allowed absolute value for each component.\n\n    Returns\n    -------\n        np.ndarray: A safe, clamped 3D vector.\n    \"\"\"\n    safe_vec = np.zeros(3)\n\n    for i in range(3):\n        val = vec[i]\n        if not np.isfinite(val):\n            #print(\"clamping\")\n            self.error = True\n            safe_vec[i] = 0.0\n        elif abs(val) &gt; max_abs:\n            #print()\n            self.error = True\n            safe_vec[i] = np.clip(val, -max_abs, max_abs)\n        else:\n            safe_vec[i] = val\n\n    return safe_vec\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.set_actual_flaps","title":"<code>set_actual_flaps(input)</code>","text":"<p>Set both actual and desired flap deflections.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>tuple of float</code> <p>Left and right flap deflections (radians).</p> required Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def set_actual_flaps(self, input):\n    \"\"\"\n    Set both actual and desired flap deflections.\n\n    Parameters\n    ----------\n    input : tuple of float\n        Left and right flap deflections (radians).\n    \"\"\"\n\n    self.flap_l,self.flap_r = input\n    self.flap_l_desired,self.flap_r_desired = input\n    self.update_flaps(1) # doesnt matter, they be the same\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.set_coefficients","title":"<code>set_coefficients(coefficients=None)</code>","text":"<p>Set the aerodynamic coefficients for the simulation. Accepts either a list (in predefined order) or a dictionary (by name).</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>list or dict</code> <p>Aerodynamic coefficients. If None, defaults are used.</p> <code>None</code> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def set_coefficients(self, coefficients=None):\n    \"\"\"\n    Set the aerodynamic coefficients for the simulation.\n    Accepts either a list (in predefined order) or a dictionary (by name).\n\n    Parameters\n    ----------\n    coefficients : list or dict, optional\n        Aerodynamic coefficients. If None, defaults are used.\n    \"\"\"\n    if coefficients is None:\n        return\n\n    # Handle dictionary input\n    if isinstance(coefficients, dict):\n        for name in [\n            \"CDo\", \"CDa\", \"CD_sym\", \"CLo\", \"CLa\", \"CL_sym\",\n            \"CYB\", \"ClB\", \"Clp\", \"Clr\", \"Cl_asym\", \"Cmo\",\n            \"Cma\", \"Cmq\", \"CnB\", \"Cn_p\", \"Cn_r\", \"Cn_asym\"\n        ]:\n            if name in coefficients:\n                setattr(self, name, coefficients[name])\n        return\n\n    # Handle list input\n    if isinstance(coefficients, list) or isinstance(coefficients, tuple):\n        if len(coefficients) &lt; 18:\n            raise ValueError(\"Coefficient list must have at least 18 values.\")\n        (\n            self.CDo, self.CDa, self.CD_sym,\n            self.CLo, self.CLa, self.CL_sym,\n            self.CYB, self.ClB, self.Clp, self.Clr, self.Cl_asym,\n            self.Cmo, self.Cma, self.Cmq,\n            self.CnB, self.Cn_p, self.Cn_r, self.Cn_asym\n        ) = coefficients\n        return\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.set_desired_flaps","title":"<code>set_desired_flaps(input)</code>","text":"<p>Set desired flap deflections.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>tuple of float</code> <p>Desired left and right flap deflections (radians).</p> required Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def set_desired_flaps(self, input):\n    \"\"\"\n    Set desired flap deflections.\n\n    Parameters\n    ----------\n    input : tuple of float\n        Desired left and right flap deflections (radians).\n    \"\"\"\n\n    self.flap_l_desired,self.flap_r_desired = input\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.set_inputs","title":"<code>set_inputs(inputs)</code>","text":"<p>Set the inputs for the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>list</code> <p>A list containing: - input[0]: Tuple[float, float], flap deflection angles (left, right). - input[1]: np.ndarray, wind vector in the inertial frame.</p> required Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def set_inputs(self, inputs):\n    \"\"\"\n    Set the inputs for the simulation.\n\n    Parameters\n    ----------\n    inputs : list\n        A list containing:\n        - input[0]: Tuple[float, float], flap deflection angles (left, right).\n        - input[1]: np.ndarray, wind vector in the inertial frame.\n    \"\"\"\n    self.set_actual_flaps(inputs[0])\n    self.w = inputs[1] # wind vector in inertial frame\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.set_state","title":"<code>set_state(state)</code>","text":"<p>Set the state of the simulation. Also updates the kinematic transformations.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>list</code> <p>State vector [position, velocity_body, eulers, angular_velocity].</p> required Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def set_state(self, state):\n    \"\"\"\n    Set the state of the simulation. Also updates the kinematic transformations.\n\n    Parameters\n    ----------\n    state : list\n        State vector [position, velocity_body, eulers, angular_velocity].\n    \"\"\"\n    self.p = state[0] # position in inertial frame\n    self.vb = self.safe_clamp_vector(state[1]) # velocity in body fixed frame\n    self.eulers = state[2] # euler angles IN RADIANS of body in inertal frame\n    self.angular_vel = self.safe_clamp_vector(state[3]) # angular velocities in body fixed frame\n    # update the transformations:\n    self.update_kinematic_transforations()\n    self.update_wind_transformations()\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.set_system_params","title":"<code>set_system_params(system_params)</code>","text":"<p>Set the system parameters for the simulation. Default values follow Snowflake PAD model.</p> <p>see: Yakimenko, Oleg A.. (2015). Precision Aerial Delivery Systems - Modeling, Dynamics, and Control <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>Keys must include: - m : float, mass [kg] - b : float, span [m] - S : float, area [m^2] - c : float, chord [m] - x_cg : float, CG x-location [m] - z_cg : float, CG z-location [m] - Ixx, Iyy, Izz, Ixz : float, inertia terms - flap_time_constant : float, flap actuator time constant - C_* : float, aerodynamic coefficients</p> required Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def set_system_params(self,system_params):\n    \"\"\"\n    Set the system parameters for the simulation. Default values follow Snowflake PAD model.\n\n    see: Yakimenko, Oleg A.. (2015). &lt;i&gt;Precision Aerial Delivery Systems - Modeling, Dynamics, and Control\n\n    Parameters\n    ----------\n    params : dict\n        Keys must include:\n        - m : float, mass [kg]\n        - b : float, span [m]\n        - S : float, area [m^2]\n        - c : float, chord [m]\n        - x_cg : float, CG x-location [m]\n        - z_cg : float, CG z-location [m]\n        - Ixx, Iyy, Izz, Ixz : float, inertia terms\n        - flap_time_constant : float, flap actuator time constant\n        - C_* : float, aerodynamic coefficients\n    \"\"\"\n    # ------------------- simulation params --------------\n    self.dt = 0.1\n    self.check_set_param(system_params, \"dt\")\n\n    # -------------------- parafoil params\n\n    # aerodynamic parameters, default values follow Snowflake PAD model.\n    self.S = 1.0\n    self.check_set_param(system_params, \"S\") # surface area of parafoil\n    self.c = 0.75\n    self.check_set_param(system_params, \"c\") # mean chord length\n    #self.AR = 0.0\n    #self.check_set_param(system_params, self.AR, \"AR\") # aspect ratio\n    self.t = 0.075\n    self.check_set_param(system_params, \"t\") # thickness of the parafoil\n    self.b = 1.35\n    self.check_set_param(system_params, \"b\") # wingspan of the parafoil\n    self.rigging_angle = np.radians(-12.0)\n    self.check_set_param(system_params, \"rigging_angle\")\n\n    # system parameters\n    self.m = 2.4 # mass of the system\n    self.check_set_param(system_params, \"m\") # mass of the system\n    self.Rp = np.array([0.0,0,-1.11]) # distance between parafoil and the center of mass for the system\n\n\n    self.check_set_param(system_params, \"Rp\")\n\n    self.I = np.array([[0.42,0,0.03],[0,0.4,0],[0.03,0,0.053]]) # moment of inertia of the system\n    # if we have to do our own calculations, we need more info\n    self.check_set_param(system_params, \"I\") # moment of inertia of the system\n\n\n    self.initial_pos = [0,0,0] # initial position of the system in inertial frame\n    self.check_set_param(system_params, \"initial_pos\")\n\n    self.flap_time_constant = 1 # number of seconds to go from 0 flap to max flap\n    self.check_set_param(system_params, \"flap_time_constant\")\n\n    \"\"\"\"\n    self.parafoil_mass = 0.0\n    self.check_set_param(system_params,self.parafoil_mass, \"parafoil_mass\") # mass of parafoil\n    self.payload_mass = 0.0\n    self.check_set_param(system_params,self.payload_mass, \"payload_mass\") # mass of payload\n    self.Rlc = 0.0\n    self.check_set_param(system_params,self.Rlc, \"Rlc\") # distance between payload CoM and connection point to parafoil\n    self.Rpc = 0.0\n    self.check_set_param(system_params,self.Rpc, \"Rpc\") # distance between parafoil CoM and connection point to parafoil\n\n    self.m = self.parafoil_mass + self.payload_mass # mass of entire system\n\n    \"\"\"\n\n    # ________________ aerodynamic parameters ____________________\n    # for drag\n    self.CD = 0\n    self.CDo = 0.25\n    self.check_set_param(system_params, \"CDo\")\n    self.CDa = 0.12\n    self.check_set_param(system_params, \"CDa\") # drag coefficient\n    self.CD_sym = 0.2\n    self.check_set_param(system_params, \"CD_sym\")\n\n    # for lift\n    self.CL = 0\n    self.CLo = 0.091\n    self.check_set_param(system_params, \"CL\") # lift coefficient\n    self.CLa = 0.90\n    self.check_set_param(system_params, \"CLa\") # lift coefficient changing due to angle of incidance\n    self.CL_sym = 0.2\n    self.check_set_param(system_params, \"CL_sym\") # lift coefficient changing due to angle of incidance\n\n    # for side force\n    self.CYB = -0.23\n    self.check_set_param(system_params, \"CYB\") # side force coefficient\n\n    # for rolling\n    self.Cl = 0\n    self.ClB = -0.036 # coefficient due to sideslip angle\n    self.check_set_param(system_params, \"clB\")\n    self.Clp = -0.84\n    self.check_set_param(system_params,\"Clp\")\n    self.Clr = -0.082\n    self.check_set_param(system_params,\"Clr\")\n    self.Cl_asym = -0.0035 # coefficient due to asymmetric flap deflection\n    self.check_set_param(system_params, \"Cl_asym\")\n\n    # for pitching\n    self.Cm = 0\n    self.Cmo = 0.35 # coefficient at zero lift\n    self.check_set_param(system_params, \"Cmo\")\n    self.Cma = -0.72 # coefficient due to angle of incidance\n    self.check_set_param(system_params, \"Cma\")\n    self.Cmq = -1.49\n    self.check_set_param(system_params, \"Cmq\") # coefficient due to pitch rate\n\n    # for yawing\n    self.Cn = 0\n    self.CnB = -0.0015 # coefficient due to sideslip angle\n    self.check_set_param(system_params, \"CnB\")\n    self.Cn_p = -0.082 # coefficient due to roll rate\n    self.check_set_param(system_params, \"Cn_p\")\n    self.Cn_r = -0.27\n    self.check_set_param(system_params, \"Cn_r\") # coefficient due to yaw rate\n    self.Cn_asym = 0.0115\n    self.check_set_param(system_params, \"Cn_asym\") # coefficient due to asymmetric flap deflection           \n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.update_flaps","title":"<code>update_flaps(dt)</code>","text":"<p>Update flap positions based on the desired values and rate limits.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>Time step (seconds).</p> required Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def update_flaps(self,dt):\n    \"\"\"\n    Update flap positions based on the desired values and rate limits.\n\n    Parameters\n    ----------\n    dt : float\n        Time step (seconds).\n    \"\"\"\n    max_rate = dt/self.flap_time_constant\n    self.flap_l += np.clip(self.flap_l_desired - self.flap_l, -max_rate, max_rate) \n    self.flap_r += np.clip(self.flap_r_desired - self.flap_r, -max_rate, max_rate) \n    # calculate the flap deflection angles\n    self.delta_a = self.flap_r - self.flap_l  # asymmetric flap deflection\n    self.delta_s = 0.5*(self.flap_l + self.flap_r) # symmetric flap deflection\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.update_kinematic_transforations","title":"<code>update_kinematic_transforations(euler_angles=None, angular_vel=None)</code>","text":"<p>Update the kinematic transformations based on the current state.</p> <p>Parameters:</p> Name Type Description Default <code>euler_angles</code> <code>tuple or list</code> <p>Euler angles (phi, theta, psi) in radians. If None, uses current state.</p> <code>None</code> <code>angular_vel</code> <code>ndarray</code> <p>Angular velocity vector (p, q, r). If None, uses current state.</p> <code>None</code> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def update_kinematic_transforations(self, euler_angles = None, angular_vel = None):\n    \"\"\"\n    Update the kinematic transformations based on the current state.\n    Parameters\n    ----------\n    euler_angles : tuple or list, optional\n        Euler angles (phi, theta, psi) in radians. If None, uses current state.\n    angular_vel : np.ndarray, optional\n        Angular velocity vector (p, q, r). If None, uses current state.\n    \"\"\"\n    if euler_angles is None:\n        euler_angles = self.eulers\n    if angular_vel is None:\n        angular_vel = self.angular_vel\n    self.CDM = self.get_CDM(euler_angles)\n    self.angular_vel_skew = self.get_angular_vel_skew(angular_vel)\n    self.T_angularVel_to_EulerRates = self.get_angular_vel_to_EulerRates_matrix(euler_angles)\n</code></pre>"},{"location":"physics/#minos.physics.six_DoF_simulator.ParafoilSimulation_6Dof.update_wind_transformations","title":"<code>update_wind_transformations()</code>","text":"<p>Update the wind-related transformations based on the current state. Calculates local airspeed, angle of attack, sideslip angle, and rotation matrix from wind to body frame.</p> Source code in <code>src\\minos\\physics\\six_DoF_simulator.py</code> <pre><code>def update_wind_transformations(self):\n    \"\"\"\n    Update the wind-related transformations based on the current state.\n    Calculates local airspeed, angle of attack, sideslip angle, and rotation matrix from wind to body frame.\n    \"\"\"\n    epsilon = 1e-8  # small value to prevent division by zero\n    # calculate local airspeed in body fixed frame\n    self.va = self.vb - self.body_to_inertial(self.w, True) # local airspeed in body fixed frame\n    if np.all(np.isfinite(self.va)):\n        self.va_mag = np.linalg.norm(self.va) # magnitude of the local airspeed in body fixed frame\n    else:\n        self.error = True\n        #print(f\"Warning: Invalid airspeed vector: va={self.va}, vb = {self.vb}\")\n        self.va = np.array([epsilon,epsilon,epsilon])\n        self.va_mag = epsilon \n\n\n\n    # Angle of attack: arctangent of vertical to forward airspeed\n    self.angle_of_attack = np.arctan2(self.va[2], self.va[0] if abs(self.va[0]) &gt; epsilon else epsilon * np.sign(self.va[0]))\n\n    # Sideslip angle: arctangent of lateral to horizontal (forward + vertical) airspeed\n    denom = np.sqrt(self.va[0]**2 + self.va[2]**2)\n    denom_safe = denom if denom &gt; epsilon else epsilon\n    self.sideslip_angle = np.arctan2(self.va[1], denom_safe)\n\n    # calculate the rotation matrix wind to body\n    self.R_wb = np.array([\n        [np.cos(self.angle_of_attack) * np.cos(self.sideslip_angle), -np.sin(self.sideslip_angle), np.cos(self.sideslip_angle) * np.sin(self.angle_of_attack)],\n        [np.sin(self.angle_of_attack) * np.cos(self.sideslip_angle), np.cos(self.angle_of_attack), np.sin(self.angle_of_attack) * np.sin(self.sideslip_angle)],\n        [-np.sin(self.angle_of_attack), 0, np.cos(self.angle_of_attack)]\n    ])\n</code></pre>"}]}